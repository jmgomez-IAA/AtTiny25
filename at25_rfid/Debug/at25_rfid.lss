
at25_rfid.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000f3a  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         0000000a  00800060  00000f3a  00000fce  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000020  0080006a  0080006a  00000fd8  2**0
                  ALLOC
  3 .stab         00003f6c  00000000  00000000  00000fd8  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      000030e8  00000000  00000000  00004f44  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .comment      00000020  00000000  00000000  0000802c  2**0
                  CONTENTS, READONLY

Disassembly of section .text:

00000000 <__vectors>:
   0:	90 c0       	rjmp	.+288    	; 0x122 <__dtors_end>
   2:	b2 c0       	rjmp	.+356    	; 0x168 <__bad_interrupt>
   4:	6f c6       	rjmp	.+3294   	; 0xce4 <__vector_2>
   6:	b0 c0       	rjmp	.+352    	; 0x168 <__bad_interrupt>
   8:	af c0       	rjmp	.+350    	; 0x168 <__bad_interrupt>
   a:	ae c0       	rjmp	.+348    	; 0x168 <__bad_interrupt>
   c:	ad c0       	rjmp	.+346    	; 0x168 <__bad_interrupt>
   e:	ac c0       	rjmp	.+344    	; 0x168 <__bad_interrupt>
  10:	ab c0       	rjmp	.+342    	; 0x168 <__bad_interrupt>
  12:	aa c0       	rjmp	.+340    	; 0x168 <__bad_interrupt>
  14:	9e c6       	rjmp	.+3388   	; 0xd52 <__vector_10>
  16:	a8 c0       	rjmp	.+336    	; 0x168 <__bad_interrupt>
  18:	a7 c0       	rjmp	.+334    	; 0x168 <__bad_interrupt>
  1a:	a6 c0       	rjmp	.+332    	; 0x168 <__bad_interrupt>
  1c:	75 c6       	rjmp	.+3306   	; 0xd08 <__vector_14>

0000001e <__trampolines_end>:
  1e:	00 d6       	rcall	.+3072   	; 0xc20 <_ZN8SPIClass9configSPIE11SPISettings+0x16>
  20:	78 8c       	ldd	r7, Y+24	; 0x18
  22:	e2 aa       	std	Z+50, r14	; 0x32
  24:	0c 18       	sub	r0, r12
  26:	2a b8       	out	0x0a, r2	; 10
  28:	7a 7f       	andi	r23, 0xFA	; 250
  2a:	d3 6a       	ori	r29, 0xA3	; 163
  2c:	cf 0b       	sbc	r28, r31
  2e:	b1 37       	cpi	r27, 0x71	; 113
  30:	63 4b       	sbci	r22, 0xB3	; 179
  32:	69 ae       	std	Y+57, r6	; 0x39
  34:	91 c7       	rjmp	.+3874   	; 0xf58 <__data_load_end+0x14>
  36:	c3 97       	sbiw	r24, 0x33	; 51
  38:	ae 77       	andi	r26, 0x7E	; 126
  3a:	f4 37       	cpi	r31, 0x74	; 116
  3c:	d7 9b       	sbis	0x1a, 7	; 26
  3e:	7c f5       	brge	.+94     	; 0x9e <_ZL30MFRC522_firmware_referenceV1_0>
  40:	3c 11       	cpse	r19, r12
  42:	8f 15       	cp	r24, r15
  44:	c3 d7       	rcall	.+3974   	; 0xfcc <__data_load_end+0x88>
  46:	c1 5b       	subi	r28, 0xB1	; 177
  48:	00 2a       	or	r0, r16
  4a:	d0 75       	andi	r29, 0x50	; 80
  4c:	de 9e       	mul	r13, r30
  4e:	51 64       	ori	r21, 0x41	; 65
  50:	ab 3e       	cpi	r26, 0xEB	; 235
  52:	e9 15       	cp	r30, r9
  54:	b5 ab       	std	Z+53, r27	; 0x35
  56:	56 9a       	sbi	0x0a, 6	; 10
  58:	98 82       	st	Y, r9
  5a:	26 ea       	ldi	r18, 0xA6	; 166
  5c:	2a 62       	ori	r18, 0x2A	; 42

0000005e <_ZL30MFRC522_firmware_referenceV2_0>:
  5e:	00 eb 66 ba 57 bf 23 95 d0 e3 0d 3d 27 89 5c de     ..f.W.#....='.\.
  6e:	9d 3b a7 00 21 5b 89 82 51 3a eb 02 0c a5 00 49     .;..![..Q:.....I
  7e:	7c 84 4d b3 cc d2 1b 81 5d 48 76 d5 71 61 21 a9     |.M.....]Hv.qa!.
  8e:	86 96 83 38 cf 9d 5b 6d dc 15 ba 3e 7d 95 3b 2f     ...8..[m...>}.;/

0000009e <_ZL30MFRC522_firmware_referenceV1_0>:
  9e:	00 c6 37 d5 32 b7 57 5c c2 d8 7c 4d d9 70 c7 73     ..7.2.W\..|M.p.s
  ae:	10 e6 d2 aa 5e a1 3e 5a 14 af 30 61 c9 70 db 2e     ....^.>Z..0a.p..
  be:	64 22 72 b5 bd 65 f4 ec 22 bc d3 72 35 cd aa 41     d"r..e.."..r5..A
  ce:	1f a7 f3 53 14 de 7e 02 d9 0f b5 5e 25 1d 29 79     ...S..~....^%.)y

000000de <_ZL30MFRC522_firmware_referenceV0_0>:
  de:	00 87 98 0f 49 ff 07 19 bf 22 30 49 59 63 ad ca     ....I...."0IYc..
  ee:	7f e3 4e 03 5c 4e 49 50 47 9a 37 61 e7 e2 c6 2e     ..N.\NIPG.7a....
  fe:	75 5a ed 04 3d 02 4b 78 32 ff 58 3b 7c e9 00 94     uZ..=.Kx2.X;|...
 10e:	b4 4a 59 5b fd c9 29 df 35 96 98 9e 4f 30 32 8d     .JY[..).5...O02.

0000011e <__ctors_start>:
 11e:	32 07       	cpc	r19, r18

00000120 <__ctors_end>:
 120:	49 07       	cpc	r20, r25

00000122 <__dtors_end>:
 122:	11 24       	eor	r1, r1
 124:	1f be       	out	0x3f, r1	; 63
 126:	cf ed       	ldi	r28, 0xDF	; 223
 128:	cd bf       	out	0x3d, r28	; 61

0000012a <__do_copy_data>:
 12a:	10 e0       	ldi	r17, 0x00	; 0
 12c:	a0 e6       	ldi	r26, 0x60	; 96
 12e:	b0 e0       	ldi	r27, 0x00	; 0
 130:	ea e3       	ldi	r30, 0x3A	; 58
 132:	ff e0       	ldi	r31, 0x0F	; 15
 134:	02 c0       	rjmp	.+4      	; 0x13a <__do_copy_data+0x10>
 136:	05 90       	lpm	r0, Z+
 138:	0d 92       	st	X+, r0
 13a:	aa 36       	cpi	r26, 0x6A	; 106
 13c:	b1 07       	cpc	r27, r17
 13e:	d9 f7       	brne	.-10     	; 0x136 <__do_copy_data+0xc>

00000140 <__do_clear_bss>:
 140:	10 e0       	ldi	r17, 0x00	; 0
 142:	aa e6       	ldi	r26, 0x6A	; 106
 144:	b0 e0       	ldi	r27, 0x00	; 0
 146:	01 c0       	rjmp	.+2      	; 0x14a <.do_clear_bss_start>

00000148 <.do_clear_bss_loop>:
 148:	1d 92       	st	X+, r1

0000014a <.do_clear_bss_start>:
 14a:	aa 38       	cpi	r26, 0x8A	; 138
 14c:	b1 07       	cpc	r27, r17
 14e:	e1 f7       	brne	.-8      	; 0x148 <.do_clear_bss_loop>

00000150 <__do_global_ctors>:
 150:	10 e0       	ldi	r17, 0x00	; 0
 152:	c0 e9       	ldi	r28, 0x90	; 144
 154:	d0 e0       	ldi	r29, 0x00	; 0
 156:	03 c0       	rjmp	.+6      	; 0x15e <__do_global_ctors+0xe>
 158:	21 97       	sbiw	r28, 0x01	; 1
 15a:	fe 01       	movw	r30, r28
 15c:	dc d6       	rcall	.+3512   	; 0xf16 <__tablejump2__>
 15e:	cf 38       	cpi	r28, 0x8F	; 143
 160:	d1 07       	cpc	r29, r17
 162:	d1 f7       	brne	.-12     	; 0x158 <__do_global_ctors+0x8>
 164:	1b d6       	rcall	.+3126   	; 0xd9c <main>
 166:	dd c6       	rjmp	.+3514   	; 0xf22 <__do_global_dtors>

00000168 <__bad_interrupt>:
 168:	4b cf       	rjmp	.-362    	; 0x0 <__vectors>

0000016a <_ZN7MFRC52219PICC_ReadCardSerialEv>:
 * The read UID is available in the class variable uid.
 * 
 * @return bool
 */
bool MFRC522::PICC_ReadCardSerial() {
	MFRC522::StatusCode result = PICC_Select(&uid);
 16a:	dc 01       	movw	r26, r24
 16c:	ed 91       	ld	r30, X+
 16e:	fd 91       	ld	r31, X+
 170:	bd 01       	movw	r22, r26
 172:	01 90       	ld	r0, Z+
 174:	f0 81       	ld	r31, Z
 176:	e0 2d       	mov	r30, r0
 178:	40 e0       	ldi	r20, 0x00	; 0
 17a:	09 95       	icall
	return (result == STATUS_OK);
 17c:	91 e0       	ldi	r25, 0x01	; 1
 17e:	81 11       	cpse	r24, r1
 180:	90 e0       	ldi	r25, 0x00	; 0
} // End 
 182:	89 2f       	mov	r24, r25
 184:	08 95       	ret

00000186 <_ZN7MFRC52216PCD_ReadRegisterENS_12PCD_RegisterEhPhh.part.0>:

/**
 * Reads a number of bytes from the specified register in the MFRC522 chip.
 * The interface is described in the datasheet section 8.1.2.
 */
void MFRC522::PCD_ReadRegister(	PCD_Register reg,	///< The register to read from. One of the PCD_Register enums.
 186:	af 92       	push	r10
 188:	bf 92       	push	r11
 18a:	cf 92       	push	r12
 18c:	df 92       	push	r13
 18e:	ef 92       	push	r14
 190:	ff 92       	push	r15
 192:	0f 93       	push	r16
 194:	1f 93       	push	r17
 196:	cf 93       	push	r28
 198:	df 93       	push	r29
 19a:	ec 01       	movw	r28, r24
 19c:	a4 2e       	mov	r10, r20
 19e:	69 01       	movw	r12, r18
								) {
	if (count == 0) {
		return;
	}
	//Serial.print(F("Reading ")); 	Serial.print(count); Serial.println(F(" bytes from register."));
	byte address = 0x80 | reg;				// MSB == 1 is for reading. LSB is not used in address. Datasheet section 8.1.2.3.
 1a0:	60 68       	ori	r22, 0x80	; 128
 1a2:	b6 2e       	mov	r11, r22
	byte index = 0;							// Index in values array.
	_spiClass->beginTransaction(_spiSettings);	// Set the settings to work with SPI bus
 1a4:	4a 89       	ldd	r20, Y+18	; 0x12
 1a6:	5b 89       	ldd	r21, Y+19	; 0x13
 1a8:	6c 89       	ldd	r22, Y+20	; 0x14
 1aa:	88 89       	ldd	r24, Y+16	; 0x10
 1ac:	99 89       	ldd	r25, Y+17	; 0x11
 1ae:	3e d5       	rcall	.+2684   	; 0xc2c <_ZN8SPIClass16beginTransactionE11SPISettings>
	digitalWrite(_chipSelectPin, LOW);		// Select slave
 1b0:	60 e0       	ldi	r22, 0x00	; 0
 1b2:	8e 85       	ldd	r24, Y+14	; 0x0e
 1b4:	71 d6       	rcall	.+3298   	; 0xe98 <_Z12digitalWritehh>
	count--;								// One read is performed outside of the loop
 1b6:	aa 94       	dec	r10
	_spiClass->transfer(address);					// Tell MFRC522 which address we want to read
 1b8:	6b 2d       	mov	r22, r11
 1ba:	88 89       	ldd	r24, Y+16	; 0x10
 1bc:	99 89       	ldd	r25, Y+17	; 0x11
 1be:	4f d5       	rcall	.+2718   	; 0xc5e <_ZN8SPIClass8transferEh>
	if (rxAlign) {		// Only update bit positions rxAlign..7 in values[0]
 1c0:	00 23       	and	r16, r16
 1c2:	a9 f0       	breq	.+42     	; 0x1ee <_ZN7MFRC52216PCD_ReadRegisterENS_12PCD_RegisterEhPhh.part.0+0x68>
		// Create bit mask for bit positions rxAlign..7
		byte mask = (0xFF << rxAlign) & 0xFF;
 1c4:	8f ef       	ldi	r24, 0xFF	; 255
 1c6:	90 e0       	ldi	r25, 0x00	; 0
 1c8:	7c 01       	movw	r14, r24
 1ca:	00 2e       	mov	r0, r16
 1cc:	01 c0       	rjmp	.+2      	; 0x1d0 <_ZN7MFRC52216PCD_ReadRegisterENS_12PCD_RegisterEhPhh.part.0+0x4a>
 1ce:	ee 0c       	add	r14, r14
 1d0:	0a 94       	dec	r0
 1d2:	ea f7       	brpl	.-6      	; 0x1ce <_ZN7MFRC52216PCD_ReadRegisterENS_12PCD_RegisterEhPhh.part.0+0x48>
		// Read value and tell that we want to read the same address again.
		byte value = _spiClass->transfer(address);
 1d4:	6b 2d       	mov	r22, r11
 1d6:	88 89       	ldd	r24, Y+16	; 0x10
 1d8:	99 89       	ldd	r25, Y+17	; 0x11
 1da:	41 d5       	rcall	.+2690   	; 0xc5e <_ZN8SPIClass8transferEh>
		// Apply mask to both current value of values[0] and the new data in value.
		values[0] = (values[0] & ~mask) | (value & mask);
 1dc:	8e 21       	and	r24, r14
 1de:	e0 94       	com	r14
 1e0:	f6 01       	movw	r30, r12
 1e2:	90 81       	ld	r25, Z
 1e4:	e9 22       	and	r14, r25
 1e6:	e8 2a       	or	r14, r24
 1e8:	e0 82       	st	Z, r14
		index++;
 1ea:	11 e0       	ldi	r17, 0x01	; 1
 1ec:	01 c0       	rjmp	.+2      	; 0x1f0 <_ZN7MFRC52216PCD_ReadRegisterENS_12PCD_RegisterEhPhh.part.0+0x6a>
	if (count == 0) {
		return;
	}
	//Serial.print(F("Reading ")); 	Serial.print(count); Serial.println(F(" bytes from register."));
	byte address = 0x80 | reg;				// MSB == 1 is for reading. LSB is not used in address. Datasheet section 8.1.2.3.
	byte index = 0;							// Index in values array.
 1ee:	10 e0       	ldi	r17, 0x00	; 0
 1f0:	88 89       	ldd	r24, Y+16	; 0x10
 1f2:	99 89       	ldd	r25, Y+17	; 0x11
 1f4:	e1 2f       	mov	r30, r17
 1f6:	f0 e0       	ldi	r31, 0x00	; 0
		byte value = _spiClass->transfer(address);
		// Apply mask to both current value of values[0] and the new data in value.
		values[0] = (values[0] & ~mask) | (value & mask);
		index++;
	}
	while (index < count) {
 1f8:	1a 15       	cp	r17, r10
 1fa:	48 f4       	brcc	.+18     	; 0x20e <_ZN7MFRC52216PCD_ReadRegisterENS_12PCD_RegisterEhPhh.part.0+0x88>
		values[index] = _spiClass->transfer(address);	// Read value and tell that we want to read the same address again.
 1fc:	76 01       	movw	r14, r12
 1fe:	ee 0e       	add	r14, r30
 200:	ff 1e       	adc	r15, r31
 202:	6b 2d       	mov	r22, r11
 204:	2c d5       	rcall	.+2648   	; 0xc5e <_ZN8SPIClass8transferEh>
 206:	f7 01       	movw	r30, r14
 208:	80 83       	st	Z, r24
		index++;
 20a:	1f 5f       	subi	r17, 0xFF	; 255
 20c:	f1 cf       	rjmp	.-30     	; 0x1f0 <_ZN7MFRC52216PCD_ReadRegisterENS_12PCD_RegisterEhPhh.part.0+0x6a>
	}
	values[index] = _spiClass->transfer(0);			// Read the final byte. Send 0 to stop reading.
 20e:	86 01       	movw	r16, r12
 210:	0e 0f       	add	r16, r30
 212:	1f 1f       	adc	r17, r31
 214:	60 e0       	ldi	r22, 0x00	; 0
 216:	23 d5       	rcall	.+2630   	; 0xc5e <_ZN8SPIClass8transferEh>
 218:	f8 01       	movw	r30, r16
 21a:	80 83       	st	Z, r24
	digitalWrite(_chipSelectPin, HIGH);			// Release slave again
 21c:	61 e0       	ldi	r22, 0x01	; 1
 21e:	8e 85       	ldd	r24, Y+14	; 0x0e
 220:	3b d6       	rcall	.+3190   	; 0xe98 <_Z12digitalWritehh>
	_spiClass->endTransaction(); // Stop using the SPI bus
 222:	88 89       	ldd	r24, Y+16	; 0x10
 224:	99 89       	ldd	r25, Y+17	; 0x11
} // End PCD_ReadRegister()
 226:	df 91       	pop	r29
 228:	cf 91       	pop	r28
 22a:	1f 91       	pop	r17
 22c:	0f 91       	pop	r16
 22e:	ff 90       	pop	r15
 230:	ef 90       	pop	r14
 232:	df 90       	pop	r13
 234:	cf 90       	pop	r12
 236:	bf 90       	pop	r11
 238:	af 90       	pop	r10
		values[index] = _spiClass->transfer(address);	// Read value and tell that we want to read the same address again.
		index++;
	}
	values[index] = _spiClass->transfer(0);			// Read the final byte. Send 0 to stop reading.
	digitalWrite(_chipSelectPin, HIGH);			// Release slave again
	_spiClass->endTransaction(); // Stop using the SPI bus
 23a:	30 c5       	rjmp	.+2656   	; 0xc9c <_ZN8SPIClass14endTransactionEv>

0000023c <_ZN7MFRC52217PCD_WriteRegisterENS_12PCD_RegisterEh>:
 * Writes a byte to the specified register in the MFRC522 chip.
 * The interface is described in the datasheet section 8.1.2.
 */
void MFRC522::PCD_WriteRegister(	PCD_Register reg,	///< The register to write to. One of the PCD_Register enums.
									byte value			///< The value to write.
								) {
 23c:	0f 93       	push	r16
 23e:	1f 93       	push	r17
 240:	cf 93       	push	r28
 242:	df 93       	push	r29
 244:	ec 01       	movw	r28, r24
 246:	06 2f       	mov	r16, r22
 248:	14 2f       	mov	r17, r20
	_spiClass->beginTransaction(_spiSettings);	// Set the settings to work with SPI bus
 24a:	4a 89       	ldd	r20, Y+18	; 0x12
 24c:	5b 89       	ldd	r21, Y+19	; 0x13
 24e:	6c 89       	ldd	r22, Y+20	; 0x14
 250:	88 89       	ldd	r24, Y+16	; 0x10
 252:	99 89       	ldd	r25, Y+17	; 0x11
 254:	eb d4       	rcall	.+2518   	; 0xc2c <_ZN8SPIClass16beginTransactionE11SPISettings>
	digitalWrite(_chipSelectPin, LOW);		// Select slave
 256:	60 e0       	ldi	r22, 0x00	; 0
 258:	8e 85       	ldd	r24, Y+14	; 0x0e
 25a:	1e d6       	rcall	.+3132   	; 0xe98 <_Z12digitalWritehh>
	_spiClass->transfer(reg);						// MSB == 0 is for writing. LSB is not used in address. Datasheet section 8.1.2.3.
 25c:	60 2f       	mov	r22, r16
 25e:	88 89       	ldd	r24, Y+16	; 0x10
 260:	99 89       	ldd	r25, Y+17	; 0x11
 262:	fd d4       	rcall	.+2554   	; 0xc5e <_ZN8SPIClass8transferEh>
	_spiClass->transfer(value);
 264:	61 2f       	mov	r22, r17
 266:	88 89       	ldd	r24, Y+16	; 0x10
 268:	99 89       	ldd	r25, Y+17	; 0x11
 26a:	f9 d4       	rcall	.+2546   	; 0xc5e <_ZN8SPIClass8transferEh>
	digitalWrite(_chipSelectPin, HIGH);		// Release slave again
 26c:	61 e0       	ldi	r22, 0x01	; 1
 26e:	8e 85       	ldd	r24, Y+14	; 0x0e
 270:	13 d6       	rcall	.+3110   	; 0xe98 <_Z12digitalWritehh>
	_spiClass->endTransaction(); // Stop using the SPI bus
 272:	88 89       	ldd	r24, Y+16	; 0x10
 274:	99 89       	ldd	r25, Y+17	; 0x11
} // End PCD_WriteRegister()
 276:	df 91       	pop	r29
 278:	cf 91       	pop	r28
 27a:	1f 91       	pop	r17
 27c:	0f 91       	pop	r16
	_spiClass->beginTransaction(_spiSettings);	// Set the settings to work with SPI bus
	digitalWrite(_chipSelectPin, LOW);		// Select slave
	_spiClass->transfer(reg);						// MSB == 0 is for writing. LSB is not used in address. Datasheet section 8.1.2.3.
	_spiClass->transfer(value);
	digitalWrite(_chipSelectPin, HIGH);		// Release slave again
	_spiClass->endTransaction(); // Stop using the SPI bus
 27e:	0e c5       	rjmp	.+2588   	; 0xc9c <_ZN8SPIClass14endTransactionEv>

00000280 <_ZN7MFRC52217PCD_WriteRegisterENS_12PCD_RegisterEhPh>:
 * The interface is described in the datasheet section 8.1.2.
 */
void MFRC522::PCD_WriteRegister(	PCD_Register reg,	///< The register to write to. One of the PCD_Register enums.
									byte count,			///< The number of bytes to write to the register
									byte *values		///< The values to write. Byte array.
								) {
 280:	cf 92       	push	r12
 282:	df 92       	push	r13
 284:	ef 92       	push	r14
 286:	ff 92       	push	r15
 288:	0f 93       	push	r16
 28a:	1f 93       	push	r17
 28c:	cf 93       	push	r28
 28e:	df 93       	push	r29
 290:	00 d0       	rcall	.+0      	; 0x292 <_ZN7MFRC52217PCD_WriteRegisterENS_12PCD_RegisterEhPh+0x12>
 292:	cd b7       	in	r28, 0x3d	; 61
 294:	dd 27       	eor	r29, r29
 296:	6c 01       	movw	r12, r24
 298:	16 2f       	mov	r17, r22
 29a:	f4 2e       	mov	r15, r20
	_spiClass->beginTransaction(_spiSettings);	// Set the settings to work with SPI bus
 29c:	fc 01       	movw	r30, r24
 29e:	42 89       	ldd	r20, Z+18	; 0x12
 2a0:	53 89       	ldd	r21, Z+19	; 0x13
 2a2:	64 89       	ldd	r22, Z+20	; 0x14
 2a4:	80 89       	ldd	r24, Z+16	; 0x10
 2a6:	91 89       	ldd	r25, Z+17	; 0x11
 2a8:	29 83       	std	Y+1, r18	; 0x01
 2aa:	3a 83       	std	Y+2, r19	; 0x02
 2ac:	bf d4       	rcall	.+2430   	; 0xc2c <_ZN8SPIClass16beginTransactionE11SPISettings>
	digitalWrite(_chipSelectPin, LOW);		// Select slave
 2ae:	60 e0       	ldi	r22, 0x00	; 0
 2b0:	f6 01       	movw	r30, r12
 2b2:	86 85       	ldd	r24, Z+14	; 0x0e
 2b4:	f1 d5       	rcall	.+3042   	; 0xe98 <_Z12digitalWritehh>
	_spiClass->transfer(reg);						// MSB == 0 is for writing. LSB is not used in address. Datasheet section 8.1.2.3.
 2b6:	61 2f       	mov	r22, r17
 2b8:	f6 01       	movw	r30, r12
 2ba:	80 89       	ldd	r24, Z+16	; 0x10
 2bc:	91 89       	ldd	r25, Z+17	; 0x11
 2be:	cf d4       	rcall	.+2462   	; 0xc5e <_ZN8SPIClass8transferEh>
 2c0:	29 81       	ldd	r18, Y+1	; 0x01
 2c2:	e2 2e       	mov	r14, r18
	for (byte index = 0; index < count; index++) {
 2c4:	02 2f       	mov	r16, r18
 2c6:	3a 81       	ldd	r19, Y+2	; 0x02
 2c8:	13 2f       	mov	r17, r19
 2ca:	80 2f       	mov	r24, r16
 2cc:	8e 19       	sub	r24, r14
 2ce:	8f 15       	cp	r24, r15
 2d0:	40 f4       	brcc	.+16     	; 0x2e2 <_ZN7MFRC52217PCD_WriteRegisterENS_12PCD_RegisterEhPh+0x62>
		_spiClass->transfer(values[index]);
 2d2:	f8 01       	movw	r30, r16
 2d4:	61 91       	ld	r22, Z+
 2d6:	8f 01       	movw	r16, r30
 2d8:	f6 01       	movw	r30, r12
 2da:	80 89       	ldd	r24, Z+16	; 0x10
 2dc:	91 89       	ldd	r25, Z+17	; 0x11
 2de:	bf d4       	rcall	.+2430   	; 0xc5e <_ZN8SPIClass8transferEh>
 2e0:	f4 cf       	rjmp	.-24     	; 0x2ca <_ZN7MFRC52217PCD_WriteRegisterENS_12PCD_RegisterEhPh+0x4a>
	}
	digitalWrite(_chipSelectPin, HIGH);		// Release slave again
 2e2:	61 e0       	ldi	r22, 0x01	; 1
 2e4:	f6 01       	movw	r30, r12
 2e6:	86 85       	ldd	r24, Z+14	; 0x0e
 2e8:	d7 d5       	rcall	.+2990   	; 0xe98 <_Z12digitalWritehh>
	_spiClass->endTransaction(); // Stop using the SPI bus
 2ea:	f6 01       	movw	r30, r12
 2ec:	80 89       	ldd	r24, Z+16	; 0x10
 2ee:	91 89       	ldd	r25, Z+17	; 0x11
} // End PCD_WriteRegister()
 2f0:	ce 5f       	subi	r28, 0xFE	; 254
 2f2:	cd bf       	out	0x3d, r28	; 61
 2f4:	df 91       	pop	r29
 2f6:	cf 91       	pop	r28
 2f8:	1f 91       	pop	r17
 2fa:	0f 91       	pop	r16
 2fc:	ff 90       	pop	r15
 2fe:	ef 90       	pop	r14
 300:	df 90       	pop	r13
 302:	cf 90       	pop	r12
	_spiClass->transfer(reg);						// MSB == 0 is for writing. LSB is not used in address. Datasheet section 8.1.2.3.
	for (byte index = 0; index < count; index++) {
		_spiClass->transfer(values[index]);
	}
	digitalWrite(_chipSelectPin, HIGH);		// Release slave again
	_spiClass->endTransaction(); // Stop using the SPI bus
 304:	cb c4       	rjmp	.+2454   	; 0xc9c <_ZN8SPIClass14endTransactionEv>

00000306 <_ZN7MFRC52216PCD_ReadRegisterENS_12PCD_RegisterE>:
/**
 * Reads a byte from the specified register in the MFRC522 chip.
 * The interface is described in the datasheet section 8.1.2.
 */
byte MFRC522::PCD_ReadRegister(	PCD_Register reg	///< The register to read from. One of the PCD_Register enums.
								) {
 306:	1f 93       	push	r17
 308:	cf 93       	push	r28
 30a:	df 93       	push	r29
 30c:	ec 01       	movw	r28, r24
 30e:	16 2f       	mov	r17, r22
	byte value;
	_spiClass->beginTransaction(_spiSettings);	// Set the settings to work with SPI bus
 310:	4a 89       	ldd	r20, Y+18	; 0x12
 312:	5b 89       	ldd	r21, Y+19	; 0x13
 314:	6c 89       	ldd	r22, Y+20	; 0x14
 316:	88 89       	ldd	r24, Y+16	; 0x10
 318:	99 89       	ldd	r25, Y+17	; 0x11
 31a:	88 d4       	rcall	.+2320   	; 0xc2c <_ZN8SPIClass16beginTransactionE11SPISettings>
	digitalWrite(_chipSelectPin, LOW);			// Select slave
 31c:	60 e0       	ldi	r22, 0x00	; 0
 31e:	8e 85       	ldd	r24, Y+14	; 0x0e
 320:	bb d5       	rcall	.+2934   	; 0xe98 <_Z12digitalWritehh>
	_spiClass->transfer(0x80 | reg);					// MSB == 1 is for reading. LSB is not used in address. Datasheet section 8.1.2.3.
 322:	61 2f       	mov	r22, r17
 324:	60 68       	ori	r22, 0x80	; 128
 326:	88 89       	ldd	r24, Y+16	; 0x10
 328:	99 89       	ldd	r25, Y+17	; 0x11
 32a:	99 d4       	rcall	.+2354   	; 0xc5e <_ZN8SPIClass8transferEh>
	value = _spiClass->transfer(0);					// Read the value back. Send 0 to stop reading.
 32c:	60 e0       	ldi	r22, 0x00	; 0
 32e:	88 89       	ldd	r24, Y+16	; 0x10
 330:	99 89       	ldd	r25, Y+17	; 0x11
 332:	95 d4       	rcall	.+2346   	; 0xc5e <_ZN8SPIClass8transferEh>
 334:	18 2f       	mov	r17, r24
	digitalWrite(_chipSelectPin, HIGH);			// Release slave again
 336:	61 e0       	ldi	r22, 0x01	; 1
 338:	8e 85       	ldd	r24, Y+14	; 0x0e
 33a:	ae d5       	rcall	.+2908   	; 0xe98 <_Z12digitalWritehh>
	_spiClass->endTransaction(); // Stop using the SPI bus
 33c:	88 89       	ldd	r24, Y+16	; 0x10
 33e:	99 89       	ldd	r25, Y+17	; 0x11
 340:	ad d4       	rcall	.+2394   	; 0xc9c <_ZN8SPIClass14endTransactionEv>
	return value;
} // End PCD_ReadRegister()
 342:	81 2f       	mov	r24, r17
 344:	df 91       	pop	r29
 346:	cf 91       	pop	r28
 348:	1f 91       	pop	r17
 34a:	08 95       	ret

0000034c <_ZN7MFRC52216PCD_ReadRegisterENS_12PCD_RegisterEhPhh>:
 */
void MFRC522::PCD_ReadRegister(	PCD_Register reg,	///< The register to read from. One of the PCD_Register enums.
								byte count,			///< The number of bytes to read
								byte *values,		///< Byte array to store the values in.
								byte rxAlign		///< Only bit positions rxAlign..7 in values[0] are updated.
								) {
 34c:	0f 93       	push	r16
	if (count == 0) {
 34e:	41 11       	cpse	r20, r1
 350:	1a df       	rcall	.-460    	; 0x186 <_ZN7MFRC52216PCD_ReadRegisterENS_12PCD_RegisterEhPhh.part.0>
		index++;
	}
	values[index] = _spiClass->transfer(0);			// Read the final byte. Send 0 to stop reading.
	digitalWrite(_chipSelectPin, HIGH);			// Release slave again
	_spiClass->endTransaction(); // Stop using the SPI bus
} // End PCD_ReadRegister()
 352:	0f 91       	pop	r16
 354:	08 95       	ret

00000356 <_ZN7MFRC52222PCD_SetRegisterBitMaskENS_12PCD_RegisterEh>:
/**
 * Sets the bits given in mask in register reg.
 */
void MFRC522::PCD_SetRegisterBitMask(	PCD_Register reg,	///< The register to update. One of the PCD_Register enums.
										byte mask			///< The bits to set.
									) { 
 356:	ef 92       	push	r14
 358:	ff 92       	push	r15
 35a:	1f 93       	push	r17
 35c:	cf 93       	push	r28
 35e:	df 93       	push	r29
 360:	1f 92       	push	r1
 362:	cd b7       	in	r28, 0x3d	; 61
 364:	dd 27       	eor	r29, r29
 366:	7c 01       	movw	r14, r24
 368:	16 2f       	mov	r17, r22
	byte tmp;
	tmp = PCD_ReadRegister(reg);
 36a:	49 83       	std	Y+1, r20	; 0x01
 36c:	cc df       	rcall	.-104    	; 0x306 <_ZN7MFRC52216PCD_ReadRegisterENS_12PCD_RegisterE>
	PCD_WriteRegister(reg, tmp | mask);			// set bit mask
 36e:	49 81       	ldd	r20, Y+1	; 0x01
 370:	48 2b       	or	r20, r24
 372:	61 2f       	mov	r22, r17
 374:	c7 01       	movw	r24, r14
} // End PCD_SetRegisterBitMask()
 376:	0f 90       	pop	r0
 378:	df 91       	pop	r29
 37a:	cf 91       	pop	r28
 37c:	1f 91       	pop	r17
 37e:	ff 90       	pop	r15
 380:	ef 90       	pop	r14
void MFRC522::PCD_SetRegisterBitMask(	PCD_Register reg,	///< The register to update. One of the PCD_Register enums.
										byte mask			///< The bits to set.
									) { 
	byte tmp;
	tmp = PCD_ReadRegister(reg);
	PCD_WriteRegister(reg, tmp | mask);			// set bit mask
 382:	5c cf       	rjmp	.-328    	; 0x23c <_ZN7MFRC52217PCD_WriteRegisterENS_12PCD_RegisterEh>

00000384 <_ZN7MFRC52224PCD_ClearRegisterBitMaskENS_12PCD_RegisterEh>:
/**
 * Clears the bits given in mask from register reg.
 */
void MFRC522::PCD_ClearRegisterBitMask(	PCD_Register reg,	///< The register to update. One of the PCD_Register enums.
										byte mask			///< The bits to clear.
									  ) {
 384:	ef 92       	push	r14
 386:	ff 92       	push	r15
 388:	1f 93       	push	r17
 38a:	cf 93       	push	r28
 38c:	df 93       	push	r29
 38e:	1f 92       	push	r1
 390:	cd b7       	in	r28, 0x3d	; 61
 392:	dd 27       	eor	r29, r29
 394:	7c 01       	movw	r14, r24
 396:	16 2f       	mov	r17, r22
	byte tmp;
	tmp = PCD_ReadRegister(reg);
 398:	49 83       	std	Y+1, r20	; 0x01
 39a:	b5 df       	rcall	.-150    	; 0x306 <_ZN7MFRC52216PCD_ReadRegisterENS_12PCD_RegisterE>
	PCD_WriteRegister(reg, tmp & (~mask));		// clear bit mask
 39c:	49 81       	ldd	r20, Y+1	; 0x01
 39e:	40 95       	com	r20
 3a0:	48 23       	and	r20, r24
 3a2:	61 2f       	mov	r22, r17
 3a4:	c7 01       	movw	r24, r14
} // End PCD_ClearRegisterBitMask()
 3a6:	0f 90       	pop	r0
 3a8:	df 91       	pop	r29
 3aa:	cf 91       	pop	r28
 3ac:	1f 91       	pop	r17
 3ae:	ff 90       	pop	r15
 3b0:	ef 90       	pop	r14
void MFRC522::PCD_ClearRegisterBitMask(	PCD_Register reg,	///< The register to update. One of the PCD_Register enums.
										byte mask			///< The bits to clear.
									  ) {
	byte tmp;
	tmp = PCD_ReadRegister(reg);
	PCD_WriteRegister(reg, tmp & (~mask));		// clear bit mask
 3b2:	44 cf       	rjmp	.-376    	; 0x23c <_ZN7MFRC52217PCD_WriteRegisterENS_12PCD_RegisterEh>

000003b4 <_ZN7MFRC52216PCD_CalculateCRCEPhhS0_>:
 * @return STATUS_OK on success, STATUS_??? otherwise.
 */
MFRC522::StatusCode MFRC522::PCD_CalculateCRC(	byte *data,		///< In: Pointer to the data to transfer to the FIFO for CRC calculation.
												byte length,	///< In: The number of bytes to transfer.
												byte *result	///< Out: Pointer to result buffer. Result is written to result[0..1], low byte first.
					 ) {
 3b4:	cf 92       	push	r12
 3b6:	df 92       	push	r13
 3b8:	ef 92       	push	r14
 3ba:	ff 92       	push	r15
 3bc:	0f 93       	push	r16
 3be:	1f 93       	push	r17
 3c0:	cf 93       	push	r28
 3c2:	df 93       	push	r29
 3c4:	ec 01       	movw	r28, r24
 3c6:	6b 01       	movw	r12, r22
 3c8:	14 2f       	mov	r17, r20
 3ca:	79 01       	movw	r14, r18
	PCD_WriteRegister(CommandReg, PCD_Idle);		// Stop any active command.
 3cc:	40 e0       	ldi	r20, 0x00	; 0
 3ce:	62 e0       	ldi	r22, 0x02	; 2
 3d0:	35 df       	rcall	.-406    	; 0x23c <_ZN7MFRC52217PCD_WriteRegisterENS_12PCD_RegisterEh>
	PCD_WriteRegister(DivIrqReg, 0x04);				// Clear the CRCIRq interrupt request bit
 3d2:	44 e0       	ldi	r20, 0x04	; 4
 3d4:	6a e0       	ldi	r22, 0x0A	; 10
 3d6:	ce 01       	movw	r24, r28
 3d8:	31 df       	rcall	.-414    	; 0x23c <_ZN7MFRC52217PCD_WriteRegisterENS_12PCD_RegisterEh>
	PCD_WriteRegister(FIFOLevelReg, 0x80);			// FlushBuffer = 1, FIFO initialization
 3da:	40 e8       	ldi	r20, 0x80	; 128
 3dc:	64 e1       	ldi	r22, 0x14	; 20
 3de:	ce 01       	movw	r24, r28
 3e0:	2d df       	rcall	.-422    	; 0x23c <_ZN7MFRC52217PCD_WriteRegisterENS_12PCD_RegisterEh>
	PCD_WriteRegister(FIFODataReg, length, data);	// Write data to the FIFO
 3e2:	96 01       	movw	r18, r12
 3e4:	41 2f       	mov	r20, r17
 3e6:	62 e1       	ldi	r22, 0x12	; 18
 3e8:	ce 01       	movw	r24, r28
 3ea:	4a df       	rcall	.-364    	; 0x280 <_ZN7MFRC52217PCD_WriteRegisterENS_12PCD_RegisterEhPh>
	PCD_WriteRegister(CommandReg, PCD_CalcCRC);		// Start the calculation
 3ec:	43 e0       	ldi	r20, 0x03	; 3
 3ee:	62 e0       	ldi	r22, 0x02	; 2
 3f0:	ce 01       	movw	r24, r28
 3f2:	24 df       	rcall	.-440    	; 0x23c <_ZN7MFRC52217PCD_WriteRegisterENS_12PCD_RegisterEh>
 3f4:	08 e8       	ldi	r16, 0x88	; 136
 3f6:	13 e1       	ldi	r17, 0x13	; 19
	// TODO check/modify for other architectures than Arduino Uno 16bit

	// Wait for the CRC calculation to complete. Each iteration of the while-loop takes 17.73us.
	for (uint16_t i = 5000; i > 0; i--) {
		// DivIrqReg[7..0] bits are: Set2 reserved reserved MfinActIRq reserved CRCIRq reserved reserved
		byte n = PCD_ReadRegister(DivIrqReg);
 3f8:	6a e0       	ldi	r22, 0x0A	; 10
 3fa:	ce 01       	movw	r24, r28
 3fc:	84 df       	rcall	.-248    	; 0x306 <_ZN7MFRC52216PCD_ReadRegisterENS_12PCD_RegisterE>
		if (n & 0x04) {									// CRCIRq bit set - calculation done
 3fe:	82 ff       	sbrs	r24, 2
 400:	10 c0       	rjmp	.+32     	; 0x422 <_ZN7MFRC52216PCD_CalculateCRCEPhhS0_+0x6e>
			PCD_WriteRegister(CommandReg, PCD_Idle);	// Stop calculating CRC for new content in the FIFO.
 402:	40 e0       	ldi	r20, 0x00	; 0
 404:	62 e0       	ldi	r22, 0x02	; 2
 406:	ce 01       	movw	r24, r28
 408:	19 df       	rcall	.-462    	; 0x23c <_ZN7MFRC52217PCD_WriteRegisterENS_12PCD_RegisterEh>
			// Transfer the result from the registers to the result buffer
			result[0] = PCD_ReadRegister(CRCResultRegL);
 40a:	64 e4       	ldi	r22, 0x44	; 68
 40c:	ce 01       	movw	r24, r28
 40e:	7b df       	rcall	.-266    	; 0x306 <_ZN7MFRC52216PCD_ReadRegisterENS_12PCD_RegisterE>
 410:	f7 01       	movw	r30, r14
 412:	80 83       	st	Z, r24
			result[1] = PCD_ReadRegister(CRCResultRegH);
 414:	62 e4       	ldi	r22, 0x42	; 66
 416:	ce 01       	movw	r24, r28
 418:	76 df       	rcall	.-276    	; 0x306 <_ZN7MFRC52216PCD_ReadRegisterENS_12PCD_RegisterE>
 41a:	f7 01       	movw	r30, r14
 41c:	81 83       	std	Z+1, r24	; 0x01
			return STATUS_OK;
 41e:	80 e0       	ldi	r24, 0x00	; 0
 420:	04 c0       	rjmp	.+8      	; 0x42a <_ZN7MFRC52216PCD_CalculateCRCEPhhS0_+0x76>
 422:	01 50       	subi	r16, 0x01	; 1
 424:	11 09       	sbc	r17, r1
	
	// Wait for the CRC calculation to complete. Each iteration of the while-loop takes 17.73μs.
	// TODO check/modify for other architectures than Arduino Uno 16bit

	// Wait for the CRC calculation to complete. Each iteration of the while-loop takes 17.73us.
	for (uint16_t i = 5000; i > 0; i--) {
 426:	41 f7       	brne	.-48     	; 0x3f8 <_ZN7MFRC52216PCD_CalculateCRCEPhhS0_+0x44>
			result[1] = PCD_ReadRegister(CRCResultRegH);
			return STATUS_OK;
		}
	}
	// 89ms passed and nothing happend. Communication with the MFRC522 might be down.
	return STATUS_TIMEOUT;
 428:	83 e0       	ldi	r24, 0x03	; 3
} // End PCD_CalculateCRC()
 42a:	df 91       	pop	r29
 42c:	cf 91       	pop	r28
 42e:	1f 91       	pop	r17
 430:	0f 91       	pop	r16
 432:	ff 90       	pop	r15
 434:	ef 90       	pop	r14
 436:	df 90       	pop	r13
 438:	cf 90       	pop	r12
 43a:	08 95       	ret

0000043c <_ZN7MFRC5229PCD_ResetEv>:
} // End PCD_Init()

/**
 * Performs a soft reset on the MFRC522 chip and waits for it to be ready again.
 */
void MFRC522::PCD_Reset() {
 43c:	cf 93       	push	r28
 43e:	df 93       	push	r29
 440:	ec 01       	movw	r28, r24
	PCD_WriteRegister(CommandReg, PCD_SoftReset);	// Issue the SoftReset command.
 442:	4f e0       	ldi	r20, 0x0F	; 15
 444:	62 e0       	ldi	r22, 0x02	; 2
 446:	fa de       	rcall	.-524    	; 0x23c <_ZN7MFRC52217PCD_WriteRegisterENS_12PCD_RegisterEh>
	// The datasheet does not mention how long the SoftRest command takes to complete.
	// But the MFRC522 might have been in soft power-down mode (triggered by bit 4 of CommandReg) 
	// Section 8.8.2 in the datasheet says the oscillator start-up time is the start up time of the crystal + 37,74μs. Let us be generous: 50ms.
	delay(50);
 448:	82 e3       	ldi	r24, 0x32	; 50
 44a:	51 d5       	rcall	.+2722   	; 0xeee <_Z5delayh>
	// Wait for the PowerDown bit in CommandReg to be cleared
	while (PCD_ReadRegister(CommandReg) & (1<<4)) {
 44c:	62 e0       	ldi	r22, 0x02	; 2
 44e:	ce 01       	movw	r24, r28
 450:	5a df       	rcall	.-332    	; 0x306 <_ZN7MFRC52216PCD_ReadRegisterENS_12PCD_RegisterE>
 452:	84 fd       	sbrc	r24, 4
 454:	fb cf       	rjmp	.-10     	; 0x44c <_ZN7MFRC5229PCD_ResetEv+0x10>
		// PCD still restarting - unlikely after waiting 50ms, but better safe than sorry.
	}
} // End PCD_Reset()
 456:	df 91       	pop	r29
 458:	cf 91       	pop	r28
 45a:	08 95       	ret

0000045c <_ZN7MFRC52213PCD_AntennaOnEv>:

/**
 * Turns the antenna on by enabling pins TX1 and TX2.
 * After a reset these pins are disabled.
 */
void MFRC522::PCD_AntennaOn() {
 45c:	cf 93       	push	r28
 45e:	df 93       	push	r29
 460:	ec 01       	movw	r28, r24
	byte value = PCD_ReadRegister(TxControlReg);
 462:	68 e2       	ldi	r22, 0x28	; 40
 464:	50 df       	rcall	.-352    	; 0x306 <_ZN7MFRC52216PCD_ReadRegisterENS_12PCD_RegisterE>
 466:	48 2f       	mov	r20, r24
	if ((value & 0x03) != 0x03) {
 468:	83 70       	andi	r24, 0x03	; 3
 46a:	83 30       	cpi	r24, 0x03	; 3
 46c:	31 f0       	breq	.+12     	; 0x47a <_ZN7MFRC52213PCD_AntennaOnEv+0x1e>
		PCD_WriteRegister(TxControlReg, value | 0x03);
 46e:	43 60       	ori	r20, 0x03	; 3
 470:	68 e2       	ldi	r22, 0x28	; 40
 472:	ce 01       	movw	r24, r28
	}
} // End PCD_AntennaOn()
 474:	df 91       	pop	r29
 476:	cf 91       	pop	r28
 * After a reset these pins are disabled.
 */
void MFRC522::PCD_AntennaOn() {
	byte value = PCD_ReadRegister(TxControlReg);
	if ((value & 0x03) != 0x03) {
		PCD_WriteRegister(TxControlReg, value | 0x03);
 478:	e1 ce       	rjmp	.-574    	; 0x23c <_ZN7MFRC52217PCD_WriteRegisterENS_12PCD_RegisterEh>
	}
} // End PCD_AntennaOn()
 47a:	df 91       	pop	r29
 47c:	cf 91       	pop	r28
 47e:	08 95       	ret

00000480 <_ZN7MFRC5228PCD_InitEv>:
/////////////////////////////////////////////////////////////////////////////////////

/**
 * Initializes the MFRC522 chip.
 */
void MFRC522::PCD_Init() {
 480:	cf 93       	push	r28
 482:	df 93       	push	r29
 484:	ec 01       	movw	r28, r24
	bool hardReset = false;

	// Set the chipSelectPin as digital output, do not select the slave yet
	pinMode(_chipSelectPin, OUTPUT);
 486:	61 e0       	ldi	r22, 0x01	; 1
 488:	8e 85       	ldd	r24, Y+14	; 0x0e
 48a:	16 d5       	rcall	.+2604   	; 0xeb8 <_Z7pinModehh>
	digitalWrite(_chipSelectPin, HIGH);
 48c:	61 e0       	ldi	r22, 0x01	; 1
 48e:	8e 85       	ldd	r24, Y+14	; 0x0e
 490:	03 d5       	rcall	.+2566   	; 0xe98 <_Z12digitalWritehh>
	
	// If a valid pin number has been set, pull device out of power down / reset state.
	if (_resetPowerDownPin != UNUSED_PIN) {
 492:	8f 85       	ldd	r24, Y+15	; 0x0f
 494:	8f 3f       	cpi	r24, 0xFF	; 255
 496:	99 f1       	breq	.+102    	; 0x4fe <_ZN7MFRC5228PCD_InitEv+0x7e>
		// Set the resetPowerDownPin as digital output, do not reset or power down.
		pinMode(_resetPowerDownPin, OUTPUT);
 498:	61 e0       	ldi	r22, 0x01	; 1
 49a:	0e d5       	rcall	.+2588   	; 0xeb8 <_Z7pinModehh>
	
		if (digitalRead(_resetPowerDownPin) == LOW) {	// The MFRC522 chip is in power down mode.
 49c:	8f 85       	ldd	r24, Y+15	; 0x0f
 49e:	25 d5       	rcall	.+2634   	; 0xeea <_Z11digitalReadh>
 4a0:	81 11       	cpse	r24, r1
 4a2:	2d c0       	rjmp	.+90     	; 0x4fe <_ZN7MFRC5228PCD_InitEv+0x7e>
			digitalWrite(_resetPowerDownPin, HIGH);		// Exit power down mode. This triggers a hard reset.
 4a4:	61 e0       	ldi	r22, 0x01	; 1
 4a6:	8f 85       	ldd	r24, Y+15	; 0x0f
 4a8:	f7 d4       	rcall	.+2542   	; 0xe98 <_Z12digitalWritehh>
			// Section 8.8.2 in the datasheet says the oscillator start-up time is the start up time of the crystal + 37,74μs. Let us be generous: 50ms.
			delay(50);
 4aa:	82 e3       	ldi	r24, 0x32	; 50
 4ac:	20 d5       	rcall	.+2624   	; 0xeee <_Z5delayh>
	if (!hardReset) { // Perform a soft reset if we haven't triggered a hard reset above.
		PCD_Reset();
	}
	
	// Reset baud rates
	PCD_WriteRegister(TxModeReg, 0x00);
 4ae:	40 e0       	ldi	r20, 0x00	; 0
 4b0:	64 e2       	ldi	r22, 0x24	; 36
 4b2:	ce 01       	movw	r24, r28
 4b4:	c3 de       	rcall	.-634    	; 0x23c <_ZN7MFRC52217PCD_WriteRegisterENS_12PCD_RegisterEh>
	PCD_WriteRegister(RxModeReg, 0x00);
 4b6:	40 e0       	ldi	r20, 0x00	; 0
 4b8:	66 e2       	ldi	r22, 0x26	; 38
 4ba:	ce 01       	movw	r24, r28
 4bc:	bf de       	rcall	.-642    	; 0x23c <_ZN7MFRC52217PCD_WriteRegisterENS_12PCD_RegisterEh>
	// Reset ModWidthReg
	PCD_WriteRegister(ModWidthReg, 0x26);
 4be:	46 e2       	ldi	r20, 0x26	; 38
 4c0:	68 e4       	ldi	r22, 0x48	; 72
 4c2:	ce 01       	movw	r24, r28
 4c4:	bb de       	rcall	.-650    	; 0x23c <_ZN7MFRC52217PCD_WriteRegisterENS_12PCD_RegisterEh>

	// When communicating with a PICC we need a timeout if something goes wrong.
	// f_timer = 13.56 MHz / (2*TPreScaler+1) where TPreScaler = [TPrescaler_Hi:TPrescaler_Lo].
	// TPrescaler_Hi are the four low bits in TModeReg. TPrescaler_Lo is TPrescalerReg.
	PCD_WriteRegister(TModeReg, 0x80);			// TAuto=1; timer starts automatically at the end of the transmission in all communication modes at all speeds
 4c6:	40 e8       	ldi	r20, 0x80	; 128
 4c8:	64 e5       	ldi	r22, 0x54	; 84
 4ca:	ce 01       	movw	r24, r28
 4cc:	b7 de       	rcall	.-658    	; 0x23c <_ZN7MFRC52217PCD_WriteRegisterENS_12PCD_RegisterEh>
	PCD_WriteRegister(TPrescalerReg, 0xA9);		// TPreScaler = TModeReg[3..0]:TPrescalerReg, ie 0x0A9 = 169 => f_timer=40kHz, ie a timer period of 25μs.
 4ce:	49 ea       	ldi	r20, 0xA9	; 169
 4d0:	66 e5       	ldi	r22, 0x56	; 86
 4d2:	ce 01       	movw	r24, r28
 4d4:	b3 de       	rcall	.-666    	; 0x23c <_ZN7MFRC52217PCD_WriteRegisterENS_12PCD_RegisterEh>
	PCD_WriteRegister(TReloadRegH, 0x03);		// Reload timer with 0x3E8 = 1000, ie 25ms before timeout.
 4d6:	43 e0       	ldi	r20, 0x03	; 3
 4d8:	68 e5       	ldi	r22, 0x58	; 88
 4da:	ce 01       	movw	r24, r28
 4dc:	af de       	rcall	.-674    	; 0x23c <_ZN7MFRC52217PCD_WriteRegisterENS_12PCD_RegisterEh>
	PCD_WriteRegister(TReloadRegL, 0xE8);
 4de:	48 ee       	ldi	r20, 0xE8	; 232
 4e0:	6a e5       	ldi	r22, 0x5A	; 90
 4e2:	ce 01       	movw	r24, r28
 4e4:	ab de       	rcall	.-682    	; 0x23c <_ZN7MFRC52217PCD_WriteRegisterENS_12PCD_RegisterEh>
	
	PCD_WriteRegister(TxASKReg, 0x40);		// Default 0x00. Force a 100 % ASK modulation independent of the ModGsPReg register setting
 4e6:	40 e4       	ldi	r20, 0x40	; 64
 4e8:	6a e2       	ldi	r22, 0x2A	; 42
 4ea:	ce 01       	movw	r24, r28
 4ec:	a7 de       	rcall	.-690    	; 0x23c <_ZN7MFRC52217PCD_WriteRegisterENS_12PCD_RegisterEh>
	PCD_WriteRegister(ModeReg, 0x3D);		// Default 0x3F. Set the preset value for the CRC coprocessor for the CalcCRC command to 0x6363 (ISO 14443-3 part 6.2.4)
 4ee:	4d e3       	ldi	r20, 0x3D	; 61
 4f0:	62 e2       	ldi	r22, 0x22	; 34
 4f2:	ce 01       	movw	r24, r28
 4f4:	a3 de       	rcall	.-698    	; 0x23c <_ZN7MFRC52217PCD_WriteRegisterENS_12PCD_RegisterEh>
	PCD_AntennaOn();						// Enable the antenna driver pins TX1 and TX2 (they were disabled by the reset)
 4f6:	ce 01       	movw	r24, r28
} // End PCD_Init()
 4f8:	df 91       	pop	r29
 4fa:	cf 91       	pop	r28
	PCD_WriteRegister(TReloadRegH, 0x03);		// Reload timer with 0x3E8 = 1000, ie 25ms before timeout.
	PCD_WriteRegister(TReloadRegL, 0xE8);
	
	PCD_WriteRegister(TxASKReg, 0x40);		// Default 0x00. Force a 100 % ASK modulation independent of the ModGsPReg register setting
	PCD_WriteRegister(ModeReg, 0x3D);		// Default 0x3F. Set the preset value for the CRC coprocessor for the CalcCRC command to 0x6363 (ISO 14443-3 part 6.2.4)
	PCD_AntennaOn();						// Enable the antenna driver pins TX1 and TX2 (they were disabled by the reset)
 4fc:	af cf       	rjmp	.-162    	; 0x45c <_ZN7MFRC52213PCD_AntennaOnEv>
			hardReset = true;
		}
	}

	if (!hardReset) { // Perform a soft reset if we haven't triggered a hard reset above.
		PCD_Reset();
 4fe:	ce 01       	movw	r24, r28
 500:	9d df       	rcall	.-198    	; 0x43c <_ZN7MFRC5229PCD_ResetEv>
 502:	d5 cf       	rjmp	.-86     	; 0x4ae <_ZN7MFRC5228PCD_InitEv+0x2e>

00000504 <_ZN7MFRC52219PCD_PerformSelfTestEv>:
 * Performs a self-test of the MFRC522
 * See 16.1.1 in http://www.nxp.com/documents/data_sheet/MFRC522.pdf
 * 
 * @return Whether or not the test passed. Or false if no firmware reference is available.
 */
bool MFRC522::PCD_PerformSelfTest() {
 504:	ef 92       	push	r14
 506:	ff 92       	push	r15
 508:	0f 93       	push	r16
 50a:	1f 93       	push	r17
 50c:	cf 93       	push	r28
 50e:	df 93       	push	r29
 510:	cd b7       	in	r28, 0x3d	; 61
 512:	dd 27       	eor	r29, r29
 514:	c9 55       	subi	r28, 0x59	; 89
 516:	cd bf       	out	0x3d, r28	; 61
 518:	7c 01       	movw	r14, r24
	// This follows directly the steps outlined in 16.1.1
	// 1. Perform a soft reset.
	PCD_Reset();
 51a:	90 df       	rcall	.-224    	; 0x43c <_ZN7MFRC5229PCD_ResetEv>
	
	// 2. Clear the internal buffer by writing 25 bytes of 00h
	byte ZEROES[25] = {0x00};
 51c:	8e 01       	movw	r16, r28
 51e:	0f 5b       	subi	r16, 0xBF	; 191
 520:	1f 4f       	sbci	r17, 0xFF	; 255
 522:	89 e1       	ldi	r24, 0x19	; 25
 524:	f8 01       	movw	r30, r16
 526:	11 92       	st	Z+, r1
 528:	8a 95       	dec	r24
 52a:	e9 f7       	brne	.-6      	; 0x526 <_ZN7MFRC52219PCD_PerformSelfTestEv+0x22>
	PCD_WriteRegister(FIFOLevelReg, 0x80);		// flush the FIFO buffer
 52c:	40 e8       	ldi	r20, 0x80	; 128
 52e:	64 e1       	ldi	r22, 0x14	; 20
 530:	c7 01       	movw	r24, r14
 532:	84 de       	rcall	.-760    	; 0x23c <_ZN7MFRC52217PCD_WriteRegisterENS_12PCD_RegisterEh>
	PCD_WriteRegister(FIFODataReg, 25, ZEROES);	// write 25 bytes of 00h to FIFO
 534:	98 01       	movw	r18, r16
 536:	49 e1       	ldi	r20, 0x19	; 25
 538:	62 e1       	ldi	r22, 0x12	; 18
 53a:	c7 01       	movw	r24, r14
 53c:	a1 de       	rcall	.-702    	; 0x280 <_ZN7MFRC52217PCD_WriteRegisterENS_12PCD_RegisterEhPh>
	PCD_WriteRegister(CommandReg, PCD_Mem);		// transfer to internal buffer
 53e:	41 e0       	ldi	r20, 0x01	; 1
 540:	62 e0       	ldi	r22, 0x02	; 2
 542:	c7 01       	movw	r24, r14
 544:	7b de       	rcall	.-778    	; 0x23c <_ZN7MFRC52217PCD_WriteRegisterENS_12PCD_RegisterEh>
	
	// 3. Enable self-test
	PCD_WriteRegister(AutoTestReg, 0x09);
 546:	49 e0       	ldi	r20, 0x09	; 9
 548:	6c e6       	ldi	r22, 0x6C	; 108
 54a:	c7 01       	movw	r24, r14
 54c:	77 de       	rcall	.-786    	; 0x23c <_ZN7MFRC52217PCD_WriteRegisterENS_12PCD_RegisterEh>
	
	// 4. Write 00h to FIFO buffer
	PCD_WriteRegister(FIFODataReg, 0x00);
 54e:	40 e0       	ldi	r20, 0x00	; 0
 550:	62 e1       	ldi	r22, 0x12	; 18
 552:	c7 01       	movw	r24, r14
 554:	73 de       	rcall	.-794    	; 0x23c <_ZN7MFRC52217PCD_WriteRegisterENS_12PCD_RegisterEh>
	
	// 5. Start self-test by issuing the CalcCRC command
	PCD_WriteRegister(CommandReg, PCD_CalcCRC);
 556:	43 e0       	ldi	r20, 0x03	; 3
 558:	62 e0       	ldi	r22, 0x02	; 2
 55a:	c7 01       	movw	r24, r14
 55c:	6f de       	rcall	.-802    	; 0x23c <_ZN7MFRC52217PCD_WriteRegisterENS_12PCD_RegisterEh>
 55e:	1f ef       	ldi	r17, 0xFF	; 255
		// While selftest is initiated by CalcCRC command
		// it behaves differently from normal CRC computation,
		// so one can't reliably use DivIrqReg to check for completion.
		// It is reported that some devices does not trigger CRCIRq flag
		// during selftest.
		n = PCD_ReadRegister(FIFOLevelReg);
 560:	64 e1       	ldi	r22, 0x14	; 20
 562:	c7 01       	movw	r24, r14
 564:	d0 de       	rcall	.-608    	; 0x306 <_ZN7MFRC52216PCD_ReadRegisterENS_12PCD_RegisterE>
		if (n >= 64) {
 566:	80 34       	cpi	r24, 0x40	; 64
 568:	10 f4       	brcc	.+4      	; 0x56e <_ZN7MFRC52219PCD_PerformSelfTestEv+0x6a>
 56a:	11 50       	subi	r17, 0x01	; 1
	// 5. Start self-test by issuing the CalcCRC command
	PCD_WriteRegister(CommandReg, PCD_CalcCRC);
	
	// 6. Wait for self-test to complete
	byte n;
	for (uint8_t i = 0; i < 0xFF; i++) {
 56c:	c9 f7       	brne	.-14     	; 0x560 <_ZN7MFRC52219PCD_PerformSelfTestEv+0x5c>
		n = PCD_ReadRegister(FIFOLevelReg);
		if (n >= 64) {
			break;
		}
	}
	PCD_WriteRegister(CommandReg, PCD_Idle);		// Stop calculating CRC for new content in the FIFO.
 56e:	40 e0       	ldi	r20, 0x00	; 0
 570:	62 e0       	ldi	r22, 0x02	; 2
 572:	c7 01       	movw	r24, r14
 574:	63 de       	rcall	.-826    	; 0x23c <_ZN7MFRC52217PCD_WriteRegisterENS_12PCD_RegisterEh>
 576:	00 e0       	ldi	r16, 0x00	; 0
 578:	9e 01       	movw	r18, r28
 57a:	2f 5f       	subi	r18, 0xFF	; 255
 57c:	3f 4f       	sbci	r19, 0xFF	; 255
 57e:	40 e4       	ldi	r20, 0x40	; 64
 580:	62 e1       	ldi	r22, 0x12	; 18
 582:	c7 01       	movw	r24, r14
 584:	00 de       	rcall	.-1024   	; 0x186 <_ZN7MFRC52216PCD_ReadRegisterENS_12PCD_RegisterEhPhh.part.0>
	byte result[64];
	PCD_ReadRegister(FIFODataReg, 64, result, 0);
	
	// Auto self-test done
	// Reset AutoTestReg register to be 0 again. Required for normal operation.
	PCD_WriteRegister(AutoTestReg, 0x00);
 586:	40 e0       	ldi	r20, 0x00	; 0
 588:	6c e6       	ldi	r22, 0x6C	; 108
 58a:	c7 01       	movw	r24, r14
 58c:	57 de       	rcall	.-850    	; 0x23c <_ZN7MFRC52217PCD_WriteRegisterENS_12PCD_RegisterEh>
	
	// Determine firmware version (see section 9.3.4.8 in spec)
	byte version = PCD_ReadRegister(VersionReg);
 58e:	6e e6       	ldi	r22, 0x6E	; 110
 590:	c7 01       	movw	r24, r14
 592:	b9 de       	rcall	.-654    	; 0x306 <_ZN7MFRC52216PCD_ReadRegisterENS_12PCD_RegisterE>
	
	// Pick the appropriate reference values
	const byte *reference;
	switch (version) {
 594:	80 39       	cpi	r24, 0x90	; 144
 596:	69 f0       	breq	.+26     	; 0x5b2 <_ZN7MFRC52219PCD_PerformSelfTestEv+0xae>
 598:	28 f4       	brcc	.+10     	; 0x5a4 <_ZN7MFRC52219PCD_PerformSelfTestEv+0xa0>
 59a:	88 38       	cpi	r24, 0x88	; 136
 59c:	e1 f4       	brne	.+56     	; 0x5d6 <_ZN7MFRC52219PCD_PerformSelfTestEv+0xd2>
		case 0x88:	// Fudan Semiconductor FM17522 clone
			reference = FM17522_firmware_reference;
 59e:	ee e1       	ldi	r30, 0x1E	; 30
 5a0:	f0 e0       	ldi	r31, 0x00	; 0
 5a2:	0c c0       	rjmp	.+24     	; 0x5bc <_ZN7MFRC52219PCD_PerformSelfTestEv+0xb8>
	// Determine firmware version (see section 9.3.4.8 in spec)
	byte version = PCD_ReadRegister(VersionReg);
	
	// Pick the appropriate reference values
	const byte *reference;
	switch (version) {
 5a4:	81 39       	cpi	r24, 0x91	; 145
 5a6:	41 f0       	breq	.+16     	; 0x5b8 <_ZN7MFRC52219PCD_PerformSelfTestEv+0xb4>
 5a8:	82 39       	cpi	r24, 0x92	; 146
 5aa:	a9 f4       	brne	.+42     	; 0x5d6 <_ZN7MFRC52219PCD_PerformSelfTestEv+0xd2>
			break;
		case 0x91:	// Version 1.0
			reference = MFRC522_firmware_referenceV1_0;
			break;
		case 0x92:	// Version 2.0
			reference = MFRC522_firmware_referenceV2_0;
 5ac:	ee e5       	ldi	r30, 0x5E	; 94
 5ae:	f0 e0       	ldi	r31, 0x00	; 0
			break;
 5b0:	05 c0       	rjmp	.+10     	; 0x5bc <_ZN7MFRC52219PCD_PerformSelfTestEv+0xb8>
	switch (version) {
		case 0x88:	// Fudan Semiconductor FM17522 clone
			reference = FM17522_firmware_reference;
			break;
		case 0x90:	// Version 0.0
			reference = MFRC522_firmware_referenceV0_0;
 5b2:	ee ed       	ldi	r30, 0xDE	; 222
 5b4:	f0 e0       	ldi	r31, 0x00	; 0
 5b6:	02 c0       	rjmp	.+4      	; 0x5bc <_ZN7MFRC52219PCD_PerformSelfTestEv+0xb8>
			break;
		case 0x91:	// Version 1.0
			reference = MFRC522_firmware_referenceV1_0;
 5b8:	ee e9       	ldi	r30, 0x9E	; 158
 5ba:	f0 e0       	ldi	r31, 0x00	; 0
			break;
		case 0x92:	// Version 2.0
			reference = MFRC522_firmware_referenceV2_0;
 5bc:	de 01       	movw	r26, r28
 5be:	11 96       	adiw	r26, 0x01	; 1
 5c0:	80 e4       	ldi	r24, 0x40	; 64
 5c2:	8a 0f       	add	r24, r26
			return false; // abort test
	}
	
	// Verify that the results match up to our expectations
	for (uint8_t i = 0; i < 64; i++) {
		if (result[i] != pgm_read_byte(&(reference[i]))) {
 5c4:	2d 91       	ld	r18, X+
 5c6:	94 91       	lpm	r25, Z
 5c8:	29 13       	cpse	r18, r25
 5ca:	05 c0       	rjmp	.+10     	; 0x5d6 <_ZN7MFRC52219PCD_PerformSelfTestEv+0xd2>
 5cc:	31 96       	adiw	r30, 0x01	; 1
		default:	// Unknown version
			return false; // abort test
	}
	
	// Verify that the results match up to our expectations
	for (uint8_t i = 0; i < 64; i++) {
 5ce:	8a 13       	cpse	r24, r26
 5d0:	f9 cf       	rjmp	.-14     	; 0x5c4 <_ZN7MFRC52219PCD_PerformSelfTestEv+0xc0>
			return false;
		}
	}
	
	// Test passed; all is good.
	return true;
 5d2:	81 e0       	ldi	r24, 0x01	; 1
 5d4:	01 c0       	rjmp	.+2      	; 0x5d8 <_ZN7MFRC52219PCD_PerformSelfTestEv+0xd4>
	}
	
	// Verify that the results match up to our expectations
	for (uint8_t i = 0; i < 64; i++) {
		if (result[i] != pgm_read_byte(&(reference[i]))) {
			return false;
 5d6:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
	
	// Test passed; all is good.
	return true;
} // End PCD_PerformSelfTest()
 5d8:	c7 5a       	subi	r28, 0xA7	; 167
 5da:	cd bf       	out	0x3d, r28	; 61
 5dc:	df 91       	pop	r29
 5de:	cf 91       	pop	r28
 5e0:	1f 91       	pop	r17
 5e2:	0f 91       	pop	r16
 5e4:	ff 90       	pop	r15
 5e6:	ef 90       	pop	r14
 5e8:	08 95       	ret

000005ea <_ZN7MFRC52223PCD_CommunicateWithPICCEhhPhhS0_S0_S0_hb>:
														byte *backData,		///< nullptr or pointer to buffer if data should be read back after executing the command.
														byte *backLen,		///< In: Max number of bytes to write to *backData. Out: The number of bytes returned.
														byte *validBits,	///< In/Out: The number of valid bits in the last byte. 0 for 8 valid bits.
														byte rxAlign,		///< In: Defines the bit position in backData[0] for the first bit received. Default 0.
														bool checkCRC		///< In: True => The last two bytes of the response is assumed to be a CRC_A that must be validated.
									 ) {
 5ea:	4f 92       	push	r4
 5ec:	5f 92       	push	r5
 5ee:	6f 92       	push	r6
 5f0:	7f 92       	push	r7
 5f2:	8f 92       	push	r8
 5f4:	9f 92       	push	r9
 5f6:	af 92       	push	r10
 5f8:	bf 92       	push	r11
 5fa:	cf 92       	push	r12
 5fc:	df 92       	push	r13
 5fe:	ef 92       	push	r14
 600:	ff 92       	push	r15
 602:	0f 93       	push	r16
 604:	1f 93       	push	r17
 606:	cf 93       	push	r28
 608:	df 93       	push	r29
 60a:	cd b7       	in	r28, 0x3d	; 61
 60c:	dd 27       	eor	r29, r29
 60e:	c4 50       	subi	r28, 0x04	; 4
 610:	cd bf       	out	0x3d, r28	; 61
 612:	3c 01       	movw	r6, r24
 614:	16 2f       	mov	r17, r22
 616:	94 2e       	mov	r9, r20
 618:	50 2e       	mov	r5, r16
 61a:	08 2d       	mov	r16, r8
	// Prepare values for BitFramingReg
	byte txLastBits = validBits ? *validBits : 0;
 61c:	a1 14       	cp	r10, r1
 61e:	b1 04       	cpc	r11, r1
 620:	19 f0       	breq	.+6      	; 0x628 <_ZN7MFRC52223PCD_CommunicateWithPICCEhhPhhS0_S0_S0_hb+0x3e>
 622:	f5 01       	movw	r30, r10
 624:	40 80       	ld	r4, Z
 626:	01 c0       	rjmp	.+2      	; 0x62a <_ZN7MFRC52223PCD_CommunicateWithPICCEhhPhhS0_S0_S0_hb+0x40>
 628:	41 2c       	mov	r4, r1
	byte bitFraming = (rxAlign << 4) + txLastBits;		// RxAlign = BitFramingReg[6..4]. TxLastBits = BitFramingReg[2..0]
 62a:	80 2f       	mov	r24, r16
 62c:	82 95       	swap	r24
 62e:	80 7f       	andi	r24, 0xF0	; 240
 630:	48 0e       	add	r4, r24
	
	PCD_WriteRegister(CommandReg, PCD_Idle);			// Stop any active command.
 632:	40 e0       	ldi	r20, 0x00	; 0
 634:	62 e0       	ldi	r22, 0x02	; 2
 636:	c3 01       	movw	r24, r6
 638:	2b 83       	std	Y+3, r18	; 0x03
 63a:	3c 83       	std	Y+4, r19	; 0x04
 63c:	ff dd       	rcall	.-1026   	; 0x23c <_ZN7MFRC52217PCD_WriteRegisterENS_12PCD_RegisterEh>
	PCD_WriteRegister(ComIrqReg, 0x7F);					// Clear all seven interrupt request bits
 63e:	4f e7       	ldi	r20, 0x7F	; 127
 640:	68 e0       	ldi	r22, 0x08	; 8
 642:	c3 01       	movw	r24, r6
 644:	fb dd       	rcall	.-1034   	; 0x23c <_ZN7MFRC52217PCD_WriteRegisterENS_12PCD_RegisterEh>
	PCD_WriteRegister(FIFOLevelReg, 0x80);				// FlushBuffer = 1, FIFO initialization
 646:	40 e8       	ldi	r20, 0x80	; 128
 648:	64 e1       	ldi	r22, 0x14	; 20
 64a:	c3 01       	movw	r24, r6
 64c:	f7 dd       	rcall	.-1042   	; 0x23c <_ZN7MFRC52217PCD_WriteRegisterENS_12PCD_RegisterEh>
	PCD_WriteRegister(FIFODataReg, sendLen, sendData);	// Write sendData to the FIFO
 64e:	2b 81       	ldd	r18, Y+3	; 0x03
 650:	3c 81       	ldd	r19, Y+4	; 0x04
 652:	45 2d       	mov	r20, r5
 654:	62 e1       	ldi	r22, 0x12	; 18
 656:	c3 01       	movw	r24, r6
 658:	13 de       	rcall	.-986    	; 0x280 <_ZN7MFRC52217PCD_WriteRegisterENS_12PCD_RegisterEhPh>
	PCD_WriteRegister(BitFramingReg, bitFraming);		// Bit adjustments
 65a:	44 2d       	mov	r20, r4
 65c:	6a e1       	ldi	r22, 0x1A	; 26
 65e:	c3 01       	movw	r24, r6
 660:	ed dd       	rcall	.-1062   	; 0x23c <_ZN7MFRC52217PCD_WriteRegisterENS_12PCD_RegisterEh>
	PCD_WriteRegister(CommandReg, command);				// Execute the command
 662:	41 2f       	mov	r20, r17
 664:	62 e0       	ldi	r22, 0x02	; 2
 666:	c3 01       	movw	r24, r6
 668:	e9 dd       	rcall	.-1070   	; 0x23c <_ZN7MFRC52217PCD_WriteRegisterENS_12PCD_RegisterEh>
	if (command == PCD_Transceive) {
 66a:	1c 30       	cpi	r17, 0x0C	; 12
 66c:	21 f4       	brne	.+8      	; 0x676 <_ZN7MFRC52223PCD_CommunicateWithPICCEhhPhhS0_S0_S0_hb+0x8c>
		PCD_SetRegisterBitMask(BitFramingReg, 0x80);	// StartSend=1, transmission of data starts
 66e:	40 e8       	ldi	r20, 0x80	; 128
 670:	6a e1       	ldi	r22, 0x1A	; 26
 672:	c3 01       	movw	r24, r6
 674:	70 de       	rcall	.-800    	; 0x356 <_ZN7MFRC52222PCD_SetRegisterBitMaskENS_12PCD_RegisterEh>
														byte *validBits,	///< In/Out: The number of valid bits in the last byte. 0 for 8 valid bits.
														byte rxAlign,		///< In: Defines the bit position in backData[0] for the first bit received. Default 0.
														bool checkCRC		///< In: True => The last two bytes of the response is assumed to be a CRC_A that must be validated.
									 ) {
	// Prepare values for BitFramingReg
	byte txLastBits = validBits ? *validBits : 0;
 676:	80 ed       	ldi	r24, 0xD0	; 208
 678:	48 2e       	mov	r4, r24
 67a:	87 e0       	ldi	r24, 0x07	; 7
 67c:	58 2e       	mov	r5, r24
	// In PCD_Init() we set the TAuto flag in TModeReg. This means the timer automatically starts when the PCD stops transmitting.
	// Each iteration of the do-while-loop takes 17.86μs.
	// TODO check/modify for other architectures than Arduino Uno 16bit
	uint16_t i;
	for (i = 2000; i > 0; i--) {
		byte n = PCD_ReadRegister(ComIrqReg);	// ComIrqReg[7..0] bits are: Set1 TxIRq RxIRq IdleIRq HiAlertIRq LoAlertIRq ErrIRq TimerIRq
 67e:	68 e0       	ldi	r22, 0x08	; 8
 680:	c3 01       	movw	r24, r6
 682:	41 de       	rcall	.-894    	; 0x306 <_ZN7MFRC52216PCD_ReadRegisterENS_12PCD_RegisterE>
		if (n & waitIRq) {					// One of the interrupts that signal success has been set.
 684:	98 2f       	mov	r25, r24
 686:	99 21       	and	r25, r9
 688:	41 f4       	brne	.+16     	; 0x69a <_ZN7MFRC52223PCD_CommunicateWithPICCEhhPhhS0_S0_S0_hb+0xb0>
			break;
		}
		if (n & 0x01) {						// Timer interrupt - nothing received in 25ms
 68a:	80 fd       	sbrc	r24, 0
 68c:	04 c0       	rjmp	.+8      	; 0x696 <_ZN7MFRC52223PCD_CommunicateWithPICCEhhPhhS0_S0_S0_hb+0xac>
 68e:	f1 e0       	ldi	r31, 0x01	; 1
 690:	4f 1a       	sub	r4, r31
 692:	51 08       	sbc	r5, r1
	// Wait for the command to complete.
	// In PCD_Init() we set the TAuto flag in TModeReg. This means the timer automatically starts when the PCD stops transmitting.
	// Each iteration of the do-while-loop takes 17.86μs.
	// TODO check/modify for other architectures than Arduino Uno 16bit
	uint16_t i;
	for (i = 2000; i > 0; i--) {
 694:	a1 f7       	brne	.-24     	; 0x67e <_ZN7MFRC52223PCD_CommunicateWithPICCEhhPhhS0_S0_S0_hb+0x94>
		byte n = PCD_ReadRegister(ComIrqReg);	// ComIrqReg[7..0] bits are: Set1 TxIRq RxIRq IdleIRq HiAlertIRq LoAlertIRq ErrIRq TimerIRq
		if (n & waitIRq) {					// One of the interrupts that signal success has been set.
			break;
		}
		if (n & 0x01) {						// Timer interrupt - nothing received in 25ms
			return STATUS_TIMEOUT;
 696:	83 e0       	ldi	r24, 0x03	; 3
 698:	60 c0       	rjmp	.+192    	; 0x75a <_ZN7MFRC52223PCD_CommunicateWithPICCEhhPhhS0_S0_S0_hb+0x170>
	if (i == 0) {
		return STATUS_TIMEOUT;
	}
	
	// Stop now if any errors except collisions were detected.
	byte errorRegValue = PCD_ReadRegister(ErrorReg); // ErrorReg[7..0] bits are: WrErr TempErr reserved BufferOvfl CollErr CRCErr ParityErr ProtocolErr
 69a:	6c e0       	ldi	r22, 0x0C	; 12
 69c:	c3 01       	movw	r24, r6
 69e:	33 de       	rcall	.-922    	; 0x306 <_ZN7MFRC52216PCD_ReadRegisterENS_12PCD_RegisterE>
 6a0:	18 2f       	mov	r17, r24
	if (errorRegValue & 0x13) {	 // BufferOvfl ParityErr ProtocolErr
 6a2:	83 71       	andi	r24, 0x13	; 19
 6a4:	09 f0       	breq	.+2      	; 0x6a8 <_ZN7MFRC52223PCD_CommunicateWithPICCEhhPhhS0_S0_S0_hb+0xbe>
 6a6:	58 c0       	rjmp	.+176    	; 0x758 <_ZN7MFRC52223PCD_CommunicateWithPICCEhhPhhS0_S0_S0_hb+0x16e>
	}
  
	byte _validBits = 0;
	
	// If the caller wants data back, get it from the MFRC522.
	if (backData && backLen) {
 6a8:	e1 14       	cp	r14, r1
 6aa:	f1 04       	cpc	r15, r1
 6ac:	d9 f0       	breq	.+54     	; 0x6e4 <_ZN7MFRC52223PCD_CommunicateWithPICCEhhPhhS0_S0_S0_hb+0xfa>
 6ae:	c1 14       	cp	r12, r1
 6b0:	d1 04       	cpc	r13, r1
 6b2:	c1 f0       	breq	.+48     	; 0x6e4 <_ZN7MFRC52223PCD_CommunicateWithPICCEhhPhhS0_S0_S0_hb+0xfa>
		byte n = PCD_ReadRegister(FIFOLevelReg);	// Number of bytes in the FIFO
 6b4:	64 e1       	ldi	r22, 0x14	; 20
 6b6:	c3 01       	movw	r24, r6
 6b8:	26 de       	rcall	.-948    	; 0x306 <_ZN7MFRC52216PCD_ReadRegisterENS_12PCD_RegisterE>
 6ba:	48 2f       	mov	r20, r24
		if (n > *backLen) {
 6bc:	f6 01       	movw	r30, r12
 6be:	80 81       	ld	r24, Z
 6c0:	84 17       	cp	r24, r20
 6c2:	08 f4       	brcc	.+2      	; 0x6c6 <_ZN7MFRC52223PCD_CommunicateWithPICCEhhPhhS0_S0_S0_hb+0xdc>
 6c4:	43 c0       	rjmp	.+134    	; 0x74c <_ZN7MFRC52223PCD_CommunicateWithPICCEhhPhhS0_S0_S0_hb+0x162>
			return STATUS_NO_ROOM;
		}
		*backLen = n;											// Number of bytes returned
 6c6:	40 83       	st	Z, r20
		PCD_ReadRegister(FIFODataReg, n, backData, rxAlign);	// Get received data from FIFO
 6c8:	97 01       	movw	r18, r14
 6ca:	62 e1       	ldi	r22, 0x12	; 18
 6cc:	c3 01       	movw	r24, r6
 6ce:	3e de       	rcall	.-900    	; 0x34c <_ZN7MFRC52216PCD_ReadRegisterENS_12PCD_RegisterEhPhh>
		_validBits = PCD_ReadRegister(ControlReg) & 0x07;		// RxLastBits[2:0] indicates the number of valid bits in the last received byte. If this value is 000b, the whole byte is valid.
 6d0:	68 e1       	ldi	r22, 0x18	; 24
 6d2:	c3 01       	movw	r24, r6
 6d4:	18 de       	rcall	.-976    	; 0x306 <_ZN7MFRC52216PCD_ReadRegisterENS_12PCD_RegisterE>
 6d6:	87 70       	andi	r24, 0x07	; 7
		if (validBits) {
 6d8:	a1 14       	cp	r10, r1
 6da:	b1 04       	cpc	r11, r1
 6dc:	21 f0       	breq	.+8      	; 0x6e6 <_ZN7MFRC52223PCD_CommunicateWithPICCEhhPhhS0_S0_S0_hb+0xfc>
			*validBits = _validBits;
 6de:	f5 01       	movw	r30, r10
 6e0:	80 83       	st	Z, r24
 6e2:	01 c0       	rjmp	.+2      	; 0x6e6 <_ZN7MFRC52223PCD_CommunicateWithPICCEhhPhhS0_S0_S0_hb+0xfc>
	byte errorRegValue = PCD_ReadRegister(ErrorReg); // ErrorReg[7..0] bits are: WrErr TempErr reserved BufferOvfl CollErr CRCErr ParityErr ProtocolErr
	if (errorRegValue & 0x13) {	 // BufferOvfl ParityErr ProtocolErr
		return STATUS_ERROR;
	}
  
	byte _validBits = 0;
 6e4:	80 e0       	ldi	r24, 0x00	; 0
			*validBits = _validBits;
		}
	}
	
	// Tell about collisions
	if (errorRegValue & 0x08) {		// CollErr
 6e6:	13 fd       	sbrc	r17, 3
 6e8:	33 c0       	rjmp	.+102    	; 0x750 <_ZN7MFRC52223PCD_CommunicateWithPICCEhhPhhS0_S0_S0_hb+0x166>
		return STATUS_COLLISION;
	}
	
	// Perform CRC_A validation if requested.
	if (backData && backLen && checkCRC) {
 6ea:	e1 14       	cp	r14, r1
 6ec:	f1 04       	cpc	r15, r1
 6ee:	91 f1       	breq	.+100    	; 0x754 <_ZN7MFRC52223PCD_CommunicateWithPICCEhhPhhS0_S0_S0_hb+0x16a>
 6f0:	c1 14       	cp	r12, r1
 6f2:	d1 04       	cpc	r13, r1
 6f4:	79 f1       	breq	.+94     	; 0x754 <_ZN7MFRC52223PCD_CommunicateWithPICCEhhPhhS0_S0_S0_hb+0x16a>
 6f6:	9f 89       	ldd	r25, Y+23	; 0x17
 6f8:	99 23       	and	r25, r25
 6fa:	61 f1       	breq	.+88     	; 0x754 <_ZN7MFRC52223PCD_CommunicateWithPICCEhhPhhS0_S0_S0_hb+0x16a>
		// In this case a MIFARE Classic NAK is not OK.
		if (*backLen == 1 && _validBits == 4) {
 6fc:	f6 01       	movw	r30, r12
 6fe:	40 81       	ld	r20, Z
 700:	41 30       	cpi	r20, 0x01	; 1
 702:	19 f4       	brne	.+6      	; 0x70a <_ZN7MFRC52223PCD_CommunicateWithPICCEhhPhhS0_S0_S0_hb+0x120>
 704:	84 30       	cpi	r24, 0x04	; 4
 706:	19 f4       	brne	.+6      	; 0x70e <_ZN7MFRC52223PCD_CommunicateWithPICCEhhPhhS0_S0_S0_hb+0x124>
 708:	1f c0       	rjmp	.+62     	; 0x748 <_ZN7MFRC52223PCD_CommunicateWithPICCEhhPhhS0_S0_S0_hb+0x15e>
			return STATUS_MIFARE_NACK;
		}
		// We need at least the CRC_A value and all 8 bits of the last byte must be received.
		if (*backLen < 2 || _validBits != 0) {
 70a:	42 30       	cpi	r20, 0x02	; 2
 70c:	10 f4       	brcc	.+4      	; 0x712 <_ZN7MFRC52223PCD_CommunicateWithPICCEhhPhhS0_S0_S0_hb+0x128>
			return STATUS_CRC_WRONG;
 70e:	87 e0       	ldi	r24, 0x07	; 7
 710:	24 c0       	rjmp	.+72     	; 0x75a <_ZN7MFRC52223PCD_CommunicateWithPICCEhhPhhS0_S0_S0_hb+0x170>
		// In this case a MIFARE Classic NAK is not OK.
		if (*backLen == 1 && _validBits == 4) {
			return STATUS_MIFARE_NACK;
		}
		// We need at least the CRC_A value and all 8 bits of the last byte must be received.
		if (*backLen < 2 || _validBits != 0) {
 712:	81 11       	cpse	r24, r1
 714:	fc cf       	rjmp	.-8      	; 0x70e <_ZN7MFRC52223PCD_CommunicateWithPICCEhhPhhS0_S0_S0_hb+0x124>
			return STATUS_CRC_WRONG;
		}
		// Verify CRC_A - do our own calculation and store the control in controlBuffer.
		byte controlBuffer[2];
		MFRC522::StatusCode status = PCD_CalculateCRC(&backData[0], *backLen - 2, &controlBuffer[0]);
 716:	42 50       	subi	r20, 0x02	; 2
 718:	9e 01       	movw	r18, r28
 71a:	2f 5f       	subi	r18, 0xFF	; 255
 71c:	3f 4f       	sbci	r19, 0xFF	; 255
 71e:	b7 01       	movw	r22, r14
 720:	c3 01       	movw	r24, r6
 722:	48 de       	rcall	.-880    	; 0x3b4 <_ZN7MFRC52216PCD_CalculateCRCEPhhS0_>
		if (status != STATUS_OK) {
 724:	81 11       	cpse	r24, r1
 726:	19 c0       	rjmp	.+50     	; 0x75a <_ZN7MFRC52223PCD_CommunicateWithPICCEhhPhhS0_S0_S0_hb+0x170>
			return status;
		}
		if ((backData[*backLen - 2] != controlBuffer[0]) || (backData[*backLen - 1] != controlBuffer[1])) {
 728:	f6 01       	movw	r30, r12
 72a:	80 81       	ld	r24, Z
 72c:	e8 0e       	add	r14, r24
 72e:	f1 1c       	adc	r15, r1
 730:	f7 01       	movw	r30, r14
 732:	32 97       	sbiw	r30, 0x02	; 2
 734:	90 81       	ld	r25, Z
 736:	89 81       	ldd	r24, Y+1	; 0x01
 738:	98 13       	cpse	r25, r24
 73a:	e9 cf       	rjmp	.-46     	; 0x70e <_ZN7MFRC52223PCD_CommunicateWithPICCEhhPhhS0_S0_S0_hb+0x124>
 73c:	31 96       	adiw	r30, 0x01	; 1
 73e:	90 81       	ld	r25, Z
 740:	8a 81       	ldd	r24, Y+2	; 0x02
 742:	98 13       	cpse	r25, r24
 744:	e4 cf       	rjmp	.-56     	; 0x70e <_ZN7MFRC52223PCD_CommunicateWithPICCEhhPhhS0_S0_S0_hb+0x124>
 746:	06 c0       	rjmp	.+12     	; 0x754 <_ZN7MFRC52223PCD_CommunicateWithPICCEhhPhhS0_S0_S0_hb+0x16a>
	
	// Perform CRC_A validation if requested.
	if (backData && backLen && checkCRC) {
		// In this case a MIFARE Classic NAK is not OK.
		if (*backLen == 1 && _validBits == 4) {
			return STATUS_MIFARE_NACK;
 748:	8f ef       	ldi	r24, 0xFF	; 255
 74a:	07 c0       	rjmp	.+14     	; 0x75a <_ZN7MFRC52223PCD_CommunicateWithPICCEhhPhhS0_S0_S0_hb+0x170>
	
	// If the caller wants data back, get it from the MFRC522.
	if (backData && backLen) {
		byte n = PCD_ReadRegister(FIFOLevelReg);	// Number of bytes in the FIFO
		if (n > *backLen) {
			return STATUS_NO_ROOM;
 74c:	84 e0       	ldi	r24, 0x04	; 4
 74e:	05 c0       	rjmp	.+10     	; 0x75a <_ZN7MFRC52223PCD_CommunicateWithPICCEhhPhhS0_S0_S0_hb+0x170>
		}
	}
	
	// Tell about collisions
	if (errorRegValue & 0x08) {		// CollErr
		return STATUS_COLLISION;
 750:	82 e0       	ldi	r24, 0x02	; 2
 752:	03 c0       	rjmp	.+6      	; 0x75a <_ZN7MFRC52223PCD_CommunicateWithPICCEhhPhhS0_S0_S0_hb+0x170>
		if ((backData[*backLen - 2] != controlBuffer[0]) || (backData[*backLen - 1] != controlBuffer[1])) {
			return STATUS_CRC_WRONG;
		}
	}
	
	return STATUS_OK;
 754:	80 e0       	ldi	r24, 0x00	; 0
 756:	01 c0       	rjmp	.+2      	; 0x75a <_ZN7MFRC52223PCD_CommunicateWithPICCEhhPhhS0_S0_S0_hb+0x170>
	}
	
	// Stop now if any errors except collisions were detected.
	byte errorRegValue = PCD_ReadRegister(ErrorReg); // ErrorReg[7..0] bits are: WrErr TempErr reserved BufferOvfl CollErr CRCErr ParityErr ProtocolErr
	if (errorRegValue & 0x13) {	 // BufferOvfl ParityErr ProtocolErr
		return STATUS_ERROR;
 758:	81 e0       	ldi	r24, 0x01	; 1
			return STATUS_CRC_WRONG;
		}
	}
	
	return STATUS_OK;
} // End PCD_CommunicateWithPICC()
 75a:	cc 5f       	subi	r28, 0xFC	; 252
 75c:	cd bf       	out	0x3d, r28	; 61
 75e:	df 91       	pop	r29
 760:	cf 91       	pop	r28
 762:	1f 91       	pop	r17
 764:	0f 91       	pop	r16
 766:	ff 90       	pop	r15
 768:	ef 90       	pop	r14
 76a:	df 90       	pop	r13
 76c:	cf 90       	pop	r12
 76e:	bf 90       	pop	r11
 770:	af 90       	pop	r10
 772:	9f 90       	pop	r9
 774:	8f 90       	pop	r8
 776:	7f 90       	pop	r7
 778:	6f 90       	pop	r6
 77a:	5f 90       	pop	r5
 77c:	4f 90       	pop	r4
 77e:	08 95       	ret

00000780 <_ZN7MFRC52218PCD_TransceiveDataEPhhS0_S0_S0_hb>:
													byte *backData,		///< nullptr or pointer to buffer if data should be read back after executing the command.
													byte *backLen,		///< In: Max number of bytes to write to *backData. Out: The number of bytes returned.
													byte *validBits,	///< In/Out: The number of valid bits in the last byte. 0 for 8 valid bits. Default nullptr.
													byte rxAlign,		///< In: Defines the bit position in backData[0] for the first bit received. Default 0.
													bool checkCRC		///< In: True => The last two bytes of the response is assumed to be a CRC_A that must be validated.
								 ) {
 780:	8f 92       	push	r8
 782:	af 92       	push	r10
 784:	bf 92       	push	r11
 786:	cf 92       	push	r12
 788:	df 92       	push	r13
 78a:	ef 92       	push	r14
 78c:	ff 92       	push	r15
 78e:	0f 93       	push	r16
 790:	1f 93       	push	r17
	byte waitIRq = 0x30;		// RxIRq and IdleIRq
	return PCD_CommunicateWithPICC(PCD_Transceive, waitIRq, sendData, sendLen, backData, backLen, validBits, rxAlign, checkCRC);
 792:	af 92       	push	r10
 794:	8c 2c       	mov	r8, r12
 796:	57 01       	movw	r10, r14
 798:	68 01       	movw	r12, r16
 79a:	79 01       	movw	r14, r18
 79c:	04 2f       	mov	r16, r20
 79e:	9b 01       	movw	r18, r22
 7a0:	40 e3       	ldi	r20, 0x30	; 48
 7a2:	6c e0       	ldi	r22, 0x0C	; 12
 7a4:	22 df       	rcall	.-444    	; 0x5ea <_ZN7MFRC52223PCD_CommunicateWithPICCEhhPhhS0_S0_S0_hb>
 7a6:	0f 90       	pop	r0
} // End PCD_TransceiveData()
 7a8:	1f 91       	pop	r17
 7aa:	0f 91       	pop	r16
 7ac:	ff 90       	pop	r15
 7ae:	ef 90       	pop	r14
 7b0:	df 90       	pop	r13
 7b2:	cf 90       	pop	r12
 7b4:	bf 90       	pop	r11
 7b6:	af 90       	pop	r10
 7b8:	8f 90       	pop	r8
 7ba:	08 95       	ret

000007bc <_ZN7MFRC52211PICC_SelectEPNS_3UidEh>:
 * 
 * @return STATUS_OK on success, STATUS_??? otherwise.
 */
MFRC522::StatusCode MFRC522::PICC_Select(	Uid *uid,			///< Pointer to Uid struct. Normally output, but can also be used to supply a known UID.
											byte validBits		///< The number of known UID bits supplied in *uid. Normally 0. If set you must also supply uid->size.
										 ) {
 7bc:	2f 92       	push	r2
 7be:	3f 92       	push	r3
 7c0:	4f 92       	push	r4
 7c2:	5f 92       	push	r5
 7c4:	6f 92       	push	r6
 7c6:	7f 92       	push	r7
 7c8:	8f 92       	push	r8
 7ca:	9f 92       	push	r9
 7cc:	af 92       	push	r10
 7ce:	bf 92       	push	r11
 7d0:	cf 92       	push	r12
 7d2:	df 92       	push	r13
 7d4:	ef 92       	push	r14
 7d6:	ff 92       	push	r15
 7d8:	0f 93       	push	r16
 7da:	1f 93       	push	r17
 7dc:	cf 93       	push	r28
 7de:	df 93       	push	r29
 7e0:	cd b7       	in	r28, 0x3d	; 61
 7e2:	dd 27       	eor	r29, r29
 7e4:	cd 50       	subi	r28, 0x0D	; 13
 7e6:	cd bf       	out	0x3d, r28	; 61
	//		10 bytes		1			CT		uid0	uid1	uid2
	//						2			CT		uid3	uid4	uid5
	//						3			uid6	uid7	uid8	uid9
	
	// Sanity checks
	if (validBits > 80) {
 7e8:	41 35       	cpi	r20, 0x51	; 81
 7ea:	08 f0       	brcs	.+2      	; 0x7ee <_ZN7MFRC52211PICC_SelectEPNS_3UidEh+0x32>
 7ec:	07 c1       	rjmp	.+526    	; 0x9fc <_ZN7MFRC52211PICC_SelectEPNS_3UidEh+0x240>
 7ee:	34 2e       	mov	r3, r20
 7f0:	3b 01       	movw	r6, r22
 7f2:	4c 01       	movw	r8, r24
		return STATUS_INVALID;
	}
	
	// Prepare MFRC522
	PCD_ClearRegisterBitMask(CollReg, 0x80);		// ValuesAfterColl=1 => Bits received after collision are cleared.
 7f4:	40 e8       	ldi	r20, 0x80	; 128
 7f6:	6c e1       	ldi	r22, 0x1C	; 28
 7f8:	c5 dd       	rcall	.-1142   	; 0x384 <_ZN7MFRC52224PCD_ClearRegisterBitMaskENS_12PCD_RegisterEh>
											byte validBits		///< The number of known UID bits supplied in *uid. Normally 0. If set you must also supply uid->size.
										 ) {
	bool uidComplete;
	bool selectDone;
	bool useCascadeTag;
	byte cascadeLevel = 1;
 7fa:	bb 24       	eor	r11, r11
 7fc:	b3 94       	inc	r11
	
	// Repeat Cascade Level loop until we have a complete UID.
	uidComplete = false;
	while (!uidComplete) {
		// Set the Cascade Level in the SEL byte, find out if we need to use the Cascade Tag in byte 2.
		switch (cascadeLevel) {
 7fe:	22 e0       	ldi	r18, 0x02	; 2
 800:	b2 16       	cp	r11, r18
 802:	91 f0       	breq	.+36     	; 0x828 <_ZN7MFRC52211PICC_SelectEPNS_3UidEh+0x6c>
 804:	33 e0       	ldi	r19, 0x03	; 3
 806:	b3 16       	cp	r11, r19
 808:	e1 f0       	breq	.+56     	; 0x842 <_ZN7MFRC52211PICC_SelectEPNS_3UidEh+0x86>
 80a:	81 e0       	ldi	r24, 0x01	; 1
 80c:	b8 12       	cpse	r11, r24
 80e:	fa c0       	rjmp	.+500    	; 0xa04 <_ZN7MFRC52211PICC_SelectEPNS_3UidEh+0x248>
			case 1:
				buffer[0] = PICC_CMD_SEL_CL1;
 810:	83 e9       	ldi	r24, 0x93	; 147
 812:	89 83       	std	Y+1, r24	; 0x01
				uidIndex = 0;
				useCascadeTag = validBits && uid->size > 4;	// When we know that the UID has more than 4 bytes
 814:	33 20       	and	r3, r3
 816:	d1 f0       	breq	.+52     	; 0x84c <_ZN7MFRC52211PICC_SelectEPNS_3UidEh+0x90>
 818:	91 e0       	ldi	r25, 0x01	; 1
 81a:	f3 01       	movw	r30, r6
 81c:	80 81       	ld	r24, Z
 81e:	85 30       	cpi	r24, 0x05	; 5
 820:	08 f4       	brcc	.+2      	; 0x824 <_ZN7MFRC52211PICC_SelectEPNS_3UidEh+0x68>
 822:	90 e0       	ldi	r25, 0x00	; 0
	while (!uidComplete) {
		// Set the Cascade Level in the SEL byte, find out if we need to use the Cascade Tag in byte 2.
		switch (cascadeLevel) {
			case 1:
				buffer[0] = PICC_CMD_SEL_CL1;
				uidIndex = 0;
 824:	d1 2c       	mov	r13, r1
 826:	17 c0       	rjmp	.+46     	; 0x856 <_ZN7MFRC52211PICC_SelectEPNS_3UidEh+0x9a>
				useCascadeTag = validBits && uid->size > 4;	// When we know that the UID has more than 4 bytes
				break;
			
			case 2:
				buffer[0] = PICC_CMD_SEL_CL2;
 828:	85 e9       	ldi	r24, 0x95	; 149
 82a:	89 83       	std	Y+1, r24	; 0x01
				uidIndex = 3;
				useCascadeTag = validBits && uid->size > 7;	// When we know that the UID has more than 7 bytes
 82c:	33 20       	and	r3, r3
 82e:	81 f0       	breq	.+32     	; 0x850 <_ZN7MFRC52211PICC_SelectEPNS_3UidEh+0x94>
 830:	91 e0       	ldi	r25, 0x01	; 1
 832:	f3 01       	movw	r30, r6
 834:	80 81       	ld	r24, Z
 836:	88 30       	cpi	r24, 0x08	; 8
 838:	08 f4       	brcc	.+2      	; 0x83c <_ZN7MFRC52211PICC_SelectEPNS_3UidEh+0x80>
 83a:	90 e0       	ldi	r25, 0x00	; 0
				useCascadeTag = validBits && uid->size > 4;	// When we know that the UID has more than 4 bytes
				break;
			
			case 2:
				buffer[0] = PICC_CMD_SEL_CL2;
				uidIndex = 3;
 83c:	53 e0       	ldi	r21, 0x03	; 3
 83e:	d5 2e       	mov	r13, r21
 840:	0a c0       	rjmp	.+20     	; 0x856 <_ZN7MFRC52211PICC_SelectEPNS_3UidEh+0x9a>
				useCascadeTag = validBits && uid->size > 7;	// When we know that the UID has more than 7 bytes
				break;
			
			case 3:
				buffer[0] = PICC_CMD_SEL_CL3;
 842:	87 e9       	ldi	r24, 0x97	; 151
 844:	89 83       	std	Y+1, r24	; 0x01
				uidIndex = 6;
 846:	46 e0       	ldi	r20, 0x06	; 6
 848:	d4 2e       	mov	r13, r20
 84a:	04 c0       	rjmp	.+8      	; 0x854 <_ZN7MFRC52211PICC_SelectEPNS_3UidEh+0x98>
	while (!uidComplete) {
		// Set the Cascade Level in the SEL byte, find out if we need to use the Cascade Tag in byte 2.
		switch (cascadeLevel) {
			case 1:
				buffer[0] = PICC_CMD_SEL_CL1;
				uidIndex = 0;
 84c:	d1 2c       	mov	r13, r1
 84e:	02 c0       	rjmp	.+4      	; 0x854 <_ZN7MFRC52211PICC_SelectEPNS_3UidEh+0x98>
				useCascadeTag = validBits && uid->size > 4;	// When we know that the UID has more than 4 bytes
				break;
			
			case 2:
				buffer[0] = PICC_CMD_SEL_CL2;
				uidIndex = 3;
 850:	33 e0       	ldi	r19, 0x03	; 3
 852:	d3 2e       	mov	r13, r19
				useCascadeTag = validBits && uid->size > 7;	// When we know that the UID has more than 7 bytes
 854:	90 e0       	ldi	r25, 0x00	; 0
				return STATUS_INTERNAL_ERROR;
				break;
		}
		
		// How many UID bits are known in this Cascade Level?
		currentLevelKnownBits = validBits - (8 * uidIndex);
 856:	8d 2d       	mov	r24, r13
 858:	88 0f       	add	r24, r24
 85a:	88 0f       	add	r24, r24
 85c:	88 0f       	add	r24, r24
 85e:	53 2d       	mov	r21, r3
 860:	58 1b       	sub	r21, r24
 862:	57 fd       	sbrc	r21, 7
 864:	50 e0       	ldi	r21, 0x00	; 0
		if (currentLevelKnownBits < 0) {
			currentLevelKnownBits = 0;
		}
		// Copy the known bits from uid->uidByte[] to buffer[]
		index = 2; // destination index in buffer[]
		if (useCascadeTag) {
 866:	99 23       	and	r25, r25
 868:	21 f0       	breq	.+8      	; 0x872 <_ZN7MFRC52211PICC_SelectEPNS_3UidEh+0xb6>
			buffer[index++] = PICC_CMD_CT;
 86a:	88 e8       	ldi	r24, 0x88	; 136
 86c:	8b 83       	std	Y+3, r24	; 0x03
 86e:	43 e0       	ldi	r20, 0x03	; 3
 870:	01 c0       	rjmp	.+2      	; 0x874 <_ZN7MFRC52211PICC_SelectEPNS_3UidEh+0xb8>
		currentLevelKnownBits = validBits - (8 * uidIndex);
		if (currentLevelKnownBits < 0) {
			currentLevelKnownBits = 0;
		}
		// Copy the known bits from uid->uidByte[] to buffer[]
		index = 2; // destination index in buffer[]
 872:	42 e0       	ldi	r20, 0x02	; 2
		if (useCascadeTag) {
			buffer[index++] = PICC_CMD_CT;
		}
		byte bytesToCopy = currentLevelKnownBits / 8 + (currentLevelKnownBits % 8 ? 1 : 0); // The number of bytes needed to represent the known bits for this level.
 874:	21 e0       	ldi	r18, 0x01	; 1
 876:	85 2f       	mov	r24, r21
 878:	87 70       	andi	r24, 0x07	; 7
 87a:	09 f4       	brne	.+2      	; 0x87e <_ZN7MFRC52211PICC_SelectEPNS_3UidEh+0xc2>
 87c:	20 e0       	ldi	r18, 0x00	; 0
 87e:	85 2f       	mov	r24, r21
 880:	85 95       	asr	r24
 882:	85 95       	asr	r24
 884:	85 95       	asr	r24
 886:	28 0f       	add	r18, r24
		if (bytesToCopy) {
 888:	21 f4       	brne	.+8      	; 0x892 <_ZN7MFRC52211PICC_SelectEPNS_3UidEh+0xd6>
			for (count = 0; count < bytesToCopy; count++) {
				buffer[index++] = uid->uidByte[uidIndex + count];
			}
		}
		// Now that the data has been copied we need to include the 8 bits in CT in currentLevelKnownBits
		if (useCascadeTag) {
 88a:	99 23       	and	r25, r25
 88c:	11 f1       	breq	.+68     	; 0x8d2 <_ZN7MFRC52211PICC_SelectEPNS_3UidEh+0x116>
			currentLevelKnownBits += 8;
 88e:	58 5f       	subi	r21, 0xF8	; 248
 890:	20 c0       	rjmp	.+64     	; 0x8d2 <_ZN7MFRC52211PICC_SelectEPNS_3UidEh+0x116>
		if (useCascadeTag) {
			buffer[index++] = PICC_CMD_CT;
		}
		byte bytesToCopy = currentLevelKnownBits / 8 + (currentLevelKnownBits % 8 ? 1 : 0); // The number of bytes needed to represent the known bits for this level.
		if (bytesToCopy) {
			byte maxBytes = useCascadeTag ? 3 : 4; // Max 4 bytes in each Cascade Level. Only 3 left if we use the Cascade Tag
 892:	91 11       	cpse	r25, r1
 894:	02 c0       	rjmp	.+4      	; 0x89a <_ZN7MFRC52211PICC_SelectEPNS_3UidEh+0xde>
 896:	84 e0       	ldi	r24, 0x04	; 4
 898:	01 c0       	rjmp	.+2      	; 0x89c <_ZN7MFRC52211PICC_SelectEPNS_3UidEh+0xe0>
 89a:	83 e0       	ldi	r24, 0x03	; 3
 89c:	28 17       	cp	r18, r24
 89e:	08 f4       	brcc	.+2      	; 0x8a2 <_ZN7MFRC52211PICC_SelectEPNS_3UidEh+0xe6>
 8a0:	82 2f       	mov	r24, r18
 8a2:	20 e0       	ldi	r18, 0x00	; 0
 8a4:	30 e0       	ldi	r19, 0x00	; 0
 8a6:	6d 2d       	mov	r22, r13
 8a8:	70 e0       	ldi	r23, 0x00	; 0
 8aa:	e4 2f       	mov	r30, r20
 8ac:	e2 0f       	add	r30, r18
			if (bytesToCopy > maxBytes) {
				bytesToCopy = maxBytes;
			}
			for (count = 0; count < bytesToCopy; count++) {
				buffer[index++] = uid->uidByte[uidIndex + count];
 8ae:	a1 e0       	ldi	r26, 0x01	; 1
 8b0:	b0 e0       	ldi	r27, 0x00	; 0
 8b2:	ac 0f       	add	r26, r28
 8b4:	bd 1f       	adc	r27, r29
 8b6:	ae 0f       	add	r26, r30
 8b8:	b1 1d       	adc	r27, r1
 8ba:	f9 01       	movw	r30, r18
 8bc:	e6 0f       	add	r30, r22
 8be:	f7 1f       	adc	r31, r23
 8c0:	e6 0d       	add	r30, r6
 8c2:	f7 1d       	adc	r31, r7
 8c4:	e1 81       	ldd	r30, Z+1	; 0x01
 8c6:	ec 93       	st	X, r30
 8c8:	2f 5f       	subi	r18, 0xFF	; 255
 8ca:	3f 4f       	sbci	r19, 0xFF	; 255
		if (bytesToCopy) {
			byte maxBytes = useCascadeTag ? 3 : 4; // Max 4 bytes in each Cascade Level. Only 3 left if we use the Cascade Tag
			if (bytesToCopy > maxBytes) {
				bytesToCopy = maxBytes;
			}
			for (count = 0; count < bytesToCopy; count++) {
 8cc:	28 17       	cp	r18, r24
 8ce:	68 f3       	brcs	.-38     	; 0x8aa <_ZN7MFRC52211PICC_SelectEPNS_3UidEh+0xee>
 8d0:	dc cf       	rjmp	.-72     	; 0x88a <_ZN7MFRC52211PICC_SelectEPNS_3UidEh+0xce>
				}
				txLastBits		= 0; // 0 => All 8 bits are valid.
				bufferUsed		= 9;
				// Store response in the last 3 bytes of buffer (BCC and CRC_A - not needed after tx)
				responseBuffer	= &buffer[6];
				responseLength	= 3;
 8d2:	23 e0       	ldi	r18, 0x03	; 3
 8d4:	22 2e       	mov	r2, r18
		
		// Repeat anti collision loop until we can transmit all UID bits + BCC and receive a SAK - max 32 iterations.
		selectDone = false;
		while (!selectDone) {
			// Find out how many bits and bytes to send and receive.
			if (currentLevelKnownBits >= 32) { // All UID bits in this Cascade Level are known. This is a SELECT.
 8d6:	50 32       	cpi	r21, 0x20	; 32
 8d8:	fc f0       	brlt	.+62     	; 0x918 <_ZN7MFRC52211PICC_SelectEPNS_3UidEh+0x15c>
				//Serial.print(F("SELECT: currentLevelKnownBits=")); Serial.println(currentLevelKnownBits, DEC);
				buffer[1] = 0x70; // NVB - Number of Valid Bits: Seven whole bytes
 8da:	f0 e7       	ldi	r31, 0x70	; 112
 8dc:	fa 83       	std	Y+2, r31	; 0x02
				// Calculate BCC - Block Check Character
				buffer[6] = buffer[2] ^ buffer[3] ^ buffer[4] ^ buffer[5];
 8de:	9c 81       	ldd	r25, Y+4	; 0x04
 8e0:	8b 81       	ldd	r24, Y+3	; 0x03
 8e2:	89 27       	eor	r24, r25
 8e4:	9d 81       	ldd	r25, Y+5	; 0x05
 8e6:	89 27       	eor	r24, r25
 8e8:	9e 81       	ldd	r25, Y+6	; 0x06
 8ea:	89 27       	eor	r24, r25
 8ec:	8f 83       	std	Y+7, r24	; 0x07
				// Calculate CRC_A
				result = PCD_CalculateCRC(buffer, 7, &buffer[7]);
 8ee:	9e 01       	movw	r18, r28
 8f0:	28 5f       	subi	r18, 0xF8	; 248
 8f2:	3f 4f       	sbci	r19, 0xFF	; 255
 8f4:	47 e0       	ldi	r20, 0x07	; 7
 8f6:	be 01       	movw	r22, r28
 8f8:	6f 5f       	subi	r22, 0xFF	; 255
 8fa:	7f 4f       	sbci	r23, 0xFF	; 255
 8fc:	c4 01       	movw	r24, r8
 8fe:	5d 87       	std	Y+13, r21	; 0x0d
 900:	59 dd       	rcall	.-1358   	; 0x3b4 <_ZN7MFRC52216PCD_CalculateCRCEPhhS0_>
				if (result != STATUS_OK) {
 902:	5d 85       	ldd	r21, Y+13	; 0x0d
 904:	81 11       	cpse	r24, r1
 906:	c9 c0       	rjmp	.+402    	; 0xa9a <_ZN7MFRC52211PICC_SelectEPNS_3UidEh+0x2de>
					return result;
				}
				txLastBits		= 0; // 0 => All 8 bits are valid.
 908:	1b 86       	std	Y+11, r1	; 0x0b
				bufferUsed		= 9;
				// Store response in the last 3 bytes of buffer (BCC and CRC_A - not needed after tx)
				responseBuffer	= &buffer[6];
				responseLength	= 3;
 90a:	2a 86       	std	Y+10, r2	; 0x0a
					return result;
				}
				txLastBits		= 0; // 0 => All 8 bits are valid.
				bufferUsed		= 9;
				// Store response in the last 3 bytes of buffer (BCC and CRC_A - not needed after tx)
				responseBuffer	= &buffer[6];
 90c:	9e 01       	movw	r18, r28
 90e:	29 5f       	subi	r18, 0xF9	; 249
 910:	3f 4f       	sbci	r19, 0xFF	; 255
 912:	29 01       	movw	r4, r18
				result = PCD_CalculateCRC(buffer, 7, &buffer[7]);
				if (result != STATUS_OK) {
					return result;
				}
				txLastBits		= 0; // 0 => All 8 bits are valid.
				bufferUsed		= 9;
 914:	79 e0       	ldi	r23, 0x09	; 9
 916:	1d c0       	rjmp	.+58     	; 0x952 <_ZN7MFRC52211PICC_SelectEPNS_3UidEh+0x196>
				responseBuffer	= &buffer[6];
				responseLength	= 3;
			}
			else { // This is an ANTICOLLISION.
				//Serial.print(F("ANTICOLLISION: currentLevelKnownBits=")); Serial.println(currentLevelKnownBits, DEC);
				txLastBits		= currentLevelKnownBits % 8;
 918:	95 2f       	mov	r25, r21
 91a:	97 70       	andi	r25, 0x07	; 7
 91c:	9b 87       	std	Y+11, r25	; 0x0b
				count			= currentLevelKnownBits / 8;	// Number of whole bytes in the UID part.
 91e:	35 2f       	mov	r19, r21
 920:	35 95       	asr	r19
 922:	35 95       	asr	r19
 924:	35 95       	asr	r19
				index			= 2 + count;					// Number of whole bytes: SEL + NVB + UIDs
 926:	82 e0       	ldi	r24, 0x02	; 2
 928:	83 0f       	add	r24, r19
				buffer[1]		= (index << 4) + txLastBits;	// NVB - Number of Valid Bits
 92a:	28 2f       	mov	r18, r24
 92c:	22 95       	swap	r18
 92e:	20 7f       	andi	r18, 0xF0	; 240
 930:	29 0f       	add	r18, r25
 932:	2a 83       	std	Y+2, r18	; 0x02
				bufferUsed		= index + (txLastBits ? 1 : 0);
 934:	71 e0       	ldi	r23, 0x01	; 1
 936:	91 11       	cpse	r25, r1
 938:	01 c0       	rjmp	.+2      	; 0x93c <_ZN7MFRC52211PICC_SelectEPNS_3UidEh+0x180>
 93a:	70 e0       	ldi	r23, 0x00	; 0
 93c:	78 0f       	add	r23, r24
				// Store response in the unused part of buffer
				responseBuffer	= &buffer[index];
 93e:	44 24       	eor	r4, r4
 940:	43 94       	inc	r4
 942:	51 2c       	mov	r5, r1
 944:	4c 0e       	add	r4, r28
 946:	5d 1e       	adc	r5, r29
 948:	48 0e       	add	r4, r24
 94a:	51 1c       	adc	r5, r1
				responseLength	= sizeof(buffer) - index;
 94c:	87 e0       	ldi	r24, 0x07	; 7
 94e:	83 1b       	sub	r24, r19
 950:	8a 87       	std	Y+10, r24	; 0x0a
			}
			
			// Set bit adjustments
			rxAlign = txLastBits;											// Having a separate variable is overkill. But it makes the next line easier to read.
 952:	cb 84       	ldd	r12, Y+11	; 0x0b
			PCD_WriteRegister(BitFramingReg, (rxAlign << 4) + txLastBits);	// RxAlign = BitFramingReg[6..4]. TxLastBits = BitFramingReg[2..0]
 954:	4c 2d       	mov	r20, r12
 956:	42 95       	swap	r20
 958:	40 7f       	andi	r20, 0xF0	; 240
 95a:	4c 0d       	add	r20, r12
 95c:	6a e1       	ldi	r22, 0x1A	; 26
 95e:	c4 01       	movw	r24, r8
 960:	5d 87       	std	Y+13, r21	; 0x0d
 962:	7c 87       	std	Y+12, r23	; 0x0c
 964:	6b dc       	rcall	.-1834   	; 0x23c <_ZN7MFRC52217PCD_WriteRegisterENS_12PCD_RegisterEh>
			
			// Transmit the buffer and receive the response.
			result = PCD_TransceiveData(buffer, bufferUsed, responseBuffer, &responseLength, &txLastBits, rxAlign);
 966:	a1 2c       	mov	r10, r1
 968:	ce 01       	movw	r24, r28
 96a:	0b 96       	adiw	r24, 0x0b	; 11
 96c:	7c 01       	movw	r14, r24
 96e:	8e 01       	movw	r16, r28
 970:	06 5f       	subi	r16, 0xF6	; 246
 972:	1f 4f       	sbci	r17, 0xFF	; 255
 974:	92 01       	movw	r18, r4
 976:	7c 85       	ldd	r23, Y+12	; 0x0c
 978:	47 2f       	mov	r20, r23
 97a:	be 01       	movw	r22, r28
 97c:	6f 5f       	subi	r22, 0xFF	; 255
 97e:	7f 4f       	sbci	r23, 0xFF	; 255
 980:	c4 01       	movw	r24, r8
 982:	fe de       	rcall	.-516    	; 0x780 <_ZN7MFRC52218PCD_TransceiveDataEPhhS0_S0_S0_hb>
			if (result == STATUS_COLLISION) { // More than one PICC in the field => collision.
 984:	5d 85       	ldd	r21, Y+13	; 0x0d
 986:	82 30       	cpi	r24, 0x02	; 2
 988:	99 f5       	brne	.+102    	; 0x9f0 <_ZN7MFRC52211PICC_SelectEPNS_3UidEh+0x234>
				byte valueOfCollReg = PCD_ReadRegister(CollReg); // CollReg[7..0] bits are: ValuesAfterColl reserved CollPosNotValid CollPos[4:0]
 98a:	6c e1       	ldi	r22, 0x1C	; 28
 98c:	c4 01       	movw	r24, r8
 98e:	bb dc       	rcall	.-1674   	; 0x306 <_ZN7MFRC52216PCD_ReadRegisterENS_12PCD_RegisterE>
				if (valueOfCollReg & 0x20) { // CollPosNotValid
 990:	5d 85       	ldd	r21, Y+13	; 0x0d
 992:	85 fd       	sbrc	r24, 5
 994:	35 c0       	rjmp	.+106    	; 0xa00 <_ZN7MFRC52211PICC_SelectEPNS_3UidEh+0x244>
					return STATUS_COLLISION; // Without a valid collision position we cannot continue
				}
				byte collisionPos = valueOfCollReg & 0x1F; // Values 0-31, 0 means bit 32.
 996:	8f 71       	andi	r24, 0x1F	; 31
				if (collisionPos == 0) {
 998:	09 f4       	brne	.+2      	; 0x99c <_ZN7MFRC52211PICC_SelectEPNS_3UidEh+0x1e0>
					collisionPos = 32;
 99a:	80 e2       	ldi	r24, 0x20	; 32
				}
				if (collisionPos <= currentLevelKnownBits) { // No progress - should not happen 
 99c:	28 2f       	mov	r18, r24
 99e:	30 e0       	ldi	r19, 0x00	; 0
 9a0:	45 2f       	mov	r20, r21
 9a2:	55 27       	eor	r21, r21
 9a4:	47 fd       	sbrc	r20, 7
 9a6:	50 95       	com	r21
 9a8:	42 17       	cp	r20, r18
 9aa:	53 07       	cpc	r21, r19
 9ac:	5c f5       	brge	.+86     	; 0xa04 <_ZN7MFRC52211PICC_SelectEPNS_3UidEh+0x248>
					return STATUS_INTERNAL_ERROR;
				}
				// Choose the PICC with the bit set.
				currentLevelKnownBits = collisionPos;
 9ae:	58 2f       	mov	r21, r24
				count			= (currentLevelKnownBits - 1) % 8; // The bit to modify
 9b0:	c9 01       	movw	r24, r18
 9b2:	01 97       	sbiw	r24, 0x01	; 1
 9b4:	87 70       	andi	r24, 0x07	; 7
 9b6:	99 27       	eor	r25, r25
				index			= 1 + (currentLevelKnownBits / 8) + (count ? 1 : 0); // First byte is index 0.
 9b8:	25 95       	asr	r18
 9ba:	25 95       	asr	r18
 9bc:	25 95       	asr	r18
 9be:	31 e0       	ldi	r19, 0x01	; 1
 9c0:	32 0f       	add	r19, r18
 9c2:	21 e0       	ldi	r18, 0x01	; 1
 9c4:	00 97       	sbiw	r24, 0x00	; 0
 9c6:	09 f4       	brne	.+2      	; 0x9ca <_ZN7MFRC52211PICC_SelectEPNS_3UidEh+0x20e>
 9c8:	20 e0       	ldi	r18, 0x00	; 0
 9ca:	23 0f       	add	r18, r19
				buffer[index]	|= (1 << count);
 9cc:	e1 e0       	ldi	r30, 0x01	; 1
 9ce:	f0 e0       	ldi	r31, 0x00	; 0
 9d0:	ec 0f       	add	r30, r28
 9d2:	fd 1f       	adc	r31, r29
 9d4:	e2 0f       	add	r30, r18
 9d6:	f1 1d       	adc	r31, r1
 9d8:	21 e0       	ldi	r18, 0x01	; 1
 9da:	30 e0       	ldi	r19, 0x00	; 0
 9dc:	02 c0       	rjmp	.+4      	; 0x9e2 <_ZN7MFRC52211PICC_SelectEPNS_3UidEh+0x226>
 9de:	22 0f       	add	r18, r18
 9e0:	33 1f       	adc	r19, r19
 9e2:	8a 95       	dec	r24
 9e4:	e2 f7       	brpl	.-8      	; 0x9de <_ZN7MFRC52211PICC_SelectEPNS_3UidEh+0x222>
 9e6:	c9 01       	movw	r24, r18
 9e8:	90 81       	ld	r25, Z
 9ea:	89 2b       	or	r24, r25
 9ec:	80 83       	st	Z, r24
 9ee:	73 cf       	rjmp	.-282    	; 0x8d6 <_ZN7MFRC52211PICC_SelectEPNS_3UidEh+0x11a>
			}
			else if (result != STATUS_OK) {
 9f0:	81 11       	cpse	r24, r1
 9f2:	53 c0       	rjmp	.+166    	; 0xa9a <_ZN7MFRC52211PICC_SelectEPNS_3UidEh+0x2de>
				return result;
			}
			else { // STATUS_OK
				if (currentLevelKnownBits >= 32) { // This was a SELECT.
 9f4:	50 32       	cpi	r21, 0x20	; 32
 9f6:	44 f4       	brge	.+16     	; 0xa08 <_ZN7MFRC52211PICC_SelectEPNS_3UidEh+0x24c>
					selectDone = true; // No more anticollision 
					// We continue below outside the while.
				}
				else { // This was an ANTICOLLISION.
					// We now have all 32 bits of the UID in this Cascade Level
					currentLevelKnownBits = 32;
 9f8:	50 e2       	ldi	r21, 0x20	; 32
 9fa:	6f cf       	rjmp	.-290    	; 0x8da <_ZN7MFRC52211PICC_SelectEPNS_3UidEh+0x11e>
	//						2			CT		uid3	uid4	uid5
	//						3			uid6	uid7	uid8	uid9
	
	// Sanity checks
	if (validBits > 80) {
		return STATUS_INVALID;
 9fc:	86 e0       	ldi	r24, 0x06	; 6
 9fe:	4d c0       	rjmp	.+154    	; 0xa9a <_ZN7MFRC52211PICC_SelectEPNS_3UidEh+0x2de>
			// Transmit the buffer and receive the response.
			result = PCD_TransceiveData(buffer, bufferUsed, responseBuffer, &responseLength, &txLastBits, rxAlign);
			if (result == STATUS_COLLISION) { // More than one PICC in the field => collision.
				byte valueOfCollReg = PCD_ReadRegister(CollReg); // CollReg[7..0] bits are: ValuesAfterColl reserved CollPosNotValid CollPos[4:0]
				if (valueOfCollReg & 0x20) { // CollPosNotValid
					return STATUS_COLLISION; // Without a valid collision position we cannot continue
 a00:	82 e0       	ldi	r24, 0x02	; 2
 a02:	4b c0       	rjmp	.+150    	; 0xa9a <_ZN7MFRC52211PICC_SelectEPNS_3UidEh+0x2de>
				byte collisionPos = valueOfCollReg & 0x1F; // Values 0-31, 0 means bit 32.
				if (collisionPos == 0) {
					collisionPos = 32;
				}
				if (collisionPos <= currentLevelKnownBits) { // No progress - should not happen 
					return STATUS_INTERNAL_ERROR;
 a04:	85 e0       	ldi	r24, 0x05	; 5
 a06:	49 c0       	rjmp	.+146    	; 0xa9a <_ZN7MFRC52211PICC_SelectEPNS_3UidEh+0x2de>
		} // End of while (!selectDone)
		
		// We do not check the CBB - it was constructed by us above.
		
		// Copy the found UID bytes from buffer[] to uid->uidByte[]
		index			= (buffer[2] == PICC_CMD_CT) ? 3 : 2; // source index in buffer[]
 a08:	8b 81       	ldd	r24, Y+3	; 0x03
 a0a:	88 38       	cpi	r24, 0x88	; 136
 a0c:	09 f0       	breq	.+2      	; 0xa10 <_ZN7MFRC52211PICC_SelectEPNS_3UidEh+0x254>
 a0e:	42 c0       	rjmp	.+132    	; 0xa94 <_ZN7MFRC52211PICC_SelectEPNS_3UidEh+0x2d8>
 a10:	33 e0       	ldi	r19, 0x03	; 3
		bytesToCopy		= (buffer[2] == PICC_CMD_CT) ? 3 : 4;
 a12:	23 e0       	ldi	r18, 0x03	; 3
 a14:	80 e0       	ldi	r24, 0x00	; 0
 a16:	90 e0       	ldi	r25, 0x00	; 0
 a18:	6d 2d       	mov	r22, r13
 a1a:	70 e0       	ldi	r23, 0x00	; 0
 a1c:	fc 01       	movw	r30, r24
 a1e:	e6 0f       	add	r30, r22
 a20:	f7 1f       	adc	r31, r23
 a22:	e6 0d       	add	r30, r6
 a24:	f7 1d       	adc	r31, r7
 a26:	43 2f       	mov	r20, r19
 a28:	48 0f       	add	r20, r24
		for (count = 0; count < bytesToCopy; count++) {
			uid->uidByte[uidIndex + count] = buffer[index++];
 a2a:	a1 e0       	ldi	r26, 0x01	; 1
 a2c:	b0 e0       	ldi	r27, 0x00	; 0
 a2e:	ac 0f       	add	r26, r28
 a30:	bd 1f       	adc	r27, r29
 a32:	a4 0f       	add	r26, r20
 a34:	b1 1d       	adc	r27, r1
 a36:	4c 91       	ld	r20, X
 a38:	41 83       	std	Z+1, r20	; 0x01
 a3a:	01 96       	adiw	r24, 0x01	; 1
		// We do not check the CBB - it was constructed by us above.
		
		// Copy the found UID bytes from buffer[] to uid->uidByte[]
		index			= (buffer[2] == PICC_CMD_CT) ? 3 : 2; // source index in buffer[]
		bytesToCopy		= (buffer[2] == PICC_CMD_CT) ? 3 : 4;
		for (count = 0; count < bytesToCopy; count++) {
 a3c:	82 17       	cp	r24, r18
 a3e:	70 f3       	brcs	.-36     	; 0xa1c <_ZN7MFRC52211PICC_SelectEPNS_3UidEh+0x260>
			uid->uidByte[uidIndex + count] = buffer[index++];
		}
		
		// Check response SAK (Select Acknowledge)
		if (responseLength != 3 || txLastBits != 0) { // SAK must be exactly 24 bits (1 byte + CRC_A).
 a40:	8a 85       	ldd	r24, Y+10	; 0x0a
 a42:	83 30       	cpi	r24, 0x03	; 3
 a44:	19 f5       	brne	.+70     	; 0xa8c <_ZN7MFRC52211PICC_SelectEPNS_3UidEh+0x2d0>
 a46:	8b 85       	ldd	r24, Y+11	; 0x0b
 a48:	81 11       	cpse	r24, r1
 a4a:	20 c0       	rjmp	.+64     	; 0xa8c <_ZN7MFRC52211PICC_SelectEPNS_3UidEh+0x2d0>
			return STATUS_ERROR;
		}
		// Verify CRC_A - do our own calculation and store the control in buffer[2..3] - those bytes are not needed anymore.
		result = PCD_CalculateCRC(responseBuffer, 1, &buffer[2]);
 a4c:	9e 01       	movw	r18, r28
 a4e:	2d 5f       	subi	r18, 0xFD	; 253
 a50:	3f 4f       	sbci	r19, 0xFF	; 255
 a52:	41 e0       	ldi	r20, 0x01	; 1
 a54:	b2 01       	movw	r22, r4
 a56:	c4 01       	movw	r24, r8
 a58:	ad dc       	rcall	.-1702   	; 0x3b4 <_ZN7MFRC52216PCD_CalculateCRCEPhhS0_>
		if (result != STATUS_OK) {
 a5a:	81 11       	cpse	r24, r1
 a5c:	1e c0       	rjmp	.+60     	; 0xa9a <_ZN7MFRC52211PICC_SelectEPNS_3UidEh+0x2de>
			return result;
		}
		if ((buffer[2] != responseBuffer[1]) || (buffer[3] != responseBuffer[2])) {
 a5e:	9b 81       	ldd	r25, Y+3	; 0x03
 a60:	f2 01       	movw	r30, r4
 a62:	81 81       	ldd	r24, Z+1	; 0x01
 a64:	98 13       	cpse	r25, r24
 a66:	14 c0       	rjmp	.+40     	; 0xa90 <_ZN7MFRC52211PICC_SelectEPNS_3UidEh+0x2d4>
 a68:	9c 81       	ldd	r25, Y+4	; 0x04
 a6a:	82 81       	ldd	r24, Z+2	; 0x02
 a6c:	98 13       	cpse	r25, r24
 a6e:	10 c0       	rjmp	.+32     	; 0xa90 <_ZN7MFRC52211PICC_SelectEPNS_3UidEh+0x2d4>
			return STATUS_CRC_WRONG;
		}
		if (responseBuffer[0] & 0x04) { // Cascade bit set - UID not complete yes
 a70:	80 81       	ld	r24, Z
 a72:	82 ff       	sbrs	r24, 2
 a74:	02 c0       	rjmp	.+4      	; 0xa7a <_ZN7MFRC52211PICC_SelectEPNS_3UidEh+0x2be>
			cascadeLevel++;
 a76:	b3 94       	inc	r11
 a78:	c2 ce       	rjmp	.-636    	; 0x7fe <_ZN7MFRC52211PICC_SelectEPNS_3UidEh+0x42>
		}
		else {
			uidComplete = true;
			uid->sak = responseBuffer[0];
 a7a:	f3 01       	movw	r30, r6
 a7c:	83 87       	std	Z+11, r24	; 0x0b
		}
	} // End of while (!uidComplete)
	
	// Set correct uid->size
	uid->size = 3 * cascadeLevel + 1;
 a7e:	8b 2d       	mov	r24, r11
 a80:	63 e0       	ldi	r22, 0x03	; 3
 a82:	40 d2       	rcall	.+1152   	; 0xf04 <__mulqi3>
 a84:	8f 5f       	subi	r24, 0xFF	; 255
 a86:	80 83       	st	Z, r24

	return STATUS_OK;
 a88:	80 e0       	ldi	r24, 0x00	; 0
 a8a:	07 c0       	rjmp	.+14     	; 0xa9a <_ZN7MFRC52211PICC_SelectEPNS_3UidEh+0x2de>
			uid->uidByte[uidIndex + count] = buffer[index++];
		}
		
		// Check response SAK (Select Acknowledge)
		if (responseLength != 3 || txLastBits != 0) { // SAK must be exactly 24 bits (1 byte + CRC_A).
			return STATUS_ERROR;
 a8c:	81 e0       	ldi	r24, 0x01	; 1
 a8e:	05 c0       	rjmp	.+10     	; 0xa9a <_ZN7MFRC52211PICC_SelectEPNS_3UidEh+0x2de>
		result = PCD_CalculateCRC(responseBuffer, 1, &buffer[2]);
		if (result != STATUS_OK) {
			return result;
		}
		if ((buffer[2] != responseBuffer[1]) || (buffer[3] != responseBuffer[2])) {
			return STATUS_CRC_WRONG;
 a90:	87 e0       	ldi	r24, 0x07	; 7
 a92:	03 c0       	rjmp	.+6      	; 0xa9a <_ZN7MFRC52211PICC_SelectEPNS_3UidEh+0x2de>
		} // End of while (!selectDone)
		
		// We do not check the CBB - it was constructed by us above.
		
		// Copy the found UID bytes from buffer[] to uid->uidByte[]
		index			= (buffer[2] == PICC_CMD_CT) ? 3 : 2; // source index in buffer[]
 a94:	32 e0       	ldi	r19, 0x02	; 2
		bytesToCopy		= (buffer[2] == PICC_CMD_CT) ? 3 : 4;
 a96:	24 e0       	ldi	r18, 0x04	; 4
 a98:	bd cf       	rjmp	.-134    	; 0xa14 <_ZN7MFRC52211PICC_SelectEPNS_3UidEh+0x258>
	
	// Set correct uid->size
	uid->size = 3 * cascadeLevel + 1;

	return STATUS_OK;
} // End PICC_Select()
 a9a:	c3 5f       	subi	r28, 0xF3	; 243
 a9c:	cd bf       	out	0x3d, r28	; 61
 a9e:	df 91       	pop	r29
 aa0:	cf 91       	pop	r28
 aa2:	1f 91       	pop	r17
 aa4:	0f 91       	pop	r16
 aa6:	ff 90       	pop	r15
 aa8:	ef 90       	pop	r14
 aaa:	df 90       	pop	r13
 aac:	cf 90       	pop	r12
 aae:	bf 90       	pop	r11
 ab0:	af 90       	pop	r10
 ab2:	9f 90       	pop	r9
 ab4:	8f 90       	pop	r8
 ab6:	7f 90       	pop	r7
 ab8:	6f 90       	pop	r6
 aba:	5f 90       	pop	r5
 abc:	4f 90       	pop	r4
 abe:	3f 90       	pop	r3
 ac0:	2f 90       	pop	r2
 ac2:	08 95       	ret

00000ac4 <_ZN7MFRC52217PICC_REQA_or_WUPAEhPhS0_>:
 * @return STATUS_OK on success, STATUS_??? otherwise.
 */ 
MFRC522::StatusCode MFRC522::PICC_REQA_or_WUPA(	byte command, 		///< The command to send - PICC_CMD_REQA or PICC_CMD_WUPA
												byte *bufferATQA,	///< The buffer to store the ATQA (Answer to request) in
												byte *bufferSize	///< Buffer size, at least two bytes. Also number of bytes returned if STATUS_OK.
											) {
 ac4:	4f 92       	push	r4
 ac6:	5f 92       	push	r5
 ac8:	6f 92       	push	r6
 aca:	7f 92       	push	r7
 acc:	8f 92       	push	r8
 ace:	9f 92       	push	r9
 ad0:	af 92       	push	r10
 ad2:	cf 92       	push	r12
 ad4:	ef 92       	push	r14
 ad6:	ff 92       	push	r15
 ad8:	0f 93       	push	r16
 ada:	1f 93       	push	r17
 adc:	cf 93       	push	r28
 ade:	df 93       	push	r29
 ae0:	00 d0       	rcall	.+0      	; 0xae2 <_ZN7MFRC52217PICC_REQA_or_WUPAEhPhS0_+0x1e>
 ae2:	cd b7       	in	r28, 0x3d	; 61
 ae4:	dd 27       	eor	r29, r29
 ae6:	6a 83       	std	Y+2, r22	; 0x02
	byte validBits;
	MFRC522::StatusCode status;
	
	if (bufferATQA == nullptr || *bufferSize < 2) {	// The ATQA response is 2 bytes long.
 ae8:	41 15       	cp	r20, r1
 aea:	51 05       	cpc	r21, r1
 aec:	29 f1       	breq	.+74     	; 0xb38 <_ZN7MFRC52217PICC_REQA_or_WUPAEhPhS0_+0x74>
 aee:	f9 01       	movw	r30, r18
 af0:	60 81       	ld	r22, Z
 af2:	62 30       	cpi	r22, 0x02	; 2
 af4:	08 f1       	brcs	.+66     	; 0xb38 <_ZN7MFRC52217PICC_REQA_or_WUPAEhPhS0_+0x74>
 af6:	49 01       	movw	r8, r18
 af8:	2a 01       	movw	r4, r20
 afa:	3c 01       	movw	r6, r24
		return STATUS_NO_ROOM;
	}
	PCD_ClearRegisterBitMask(CollReg, 0x80);		// ValuesAfterColl=1 => Bits received after collision are cleared.
 afc:	40 e8       	ldi	r20, 0x80	; 128
 afe:	6c e1       	ldi	r22, 0x1C	; 28
 b00:	41 dc       	rcall	.-1918   	; 0x384 <_ZN7MFRC52224PCD_ClearRegisterBitMaskENS_12PCD_RegisterEh>
	validBits = 7;									// For REQA and WUPA we need the short frame format - transmit only 7 bits of the last (and only) byte. TxLastBits = BitFramingReg[2..0]
 b02:	87 e0       	ldi	r24, 0x07	; 7
 b04:	89 83       	std	Y+1, r24	; 0x01
	status = PCD_TransceiveData(&command, 1, bufferATQA, bufferSize, &validBits);
 b06:	a1 2c       	mov	r10, r1
 b08:	c1 2c       	mov	r12, r1
 b0a:	ce 01       	movw	r24, r28
 b0c:	01 96       	adiw	r24, 0x01	; 1
 b0e:	7c 01       	movw	r14, r24
 b10:	84 01       	movw	r16, r8
 b12:	92 01       	movw	r18, r4
 b14:	41 e0       	ldi	r20, 0x01	; 1
 b16:	be 01       	movw	r22, r28
 b18:	6e 5f       	subi	r22, 0xFE	; 254
 b1a:	7f 4f       	sbci	r23, 0xFF	; 255
 b1c:	c3 01       	movw	r24, r6
 b1e:	30 de       	rcall	.-928    	; 0x780 <_ZN7MFRC52218PCD_TransceiveDataEPhhS0_S0_S0_hb>
	if (status != STATUS_OK) {
 b20:	81 11       	cpse	r24, r1
 b22:	0d c0       	rjmp	.+26     	; 0xb3e <_ZN7MFRC52217PICC_REQA_or_WUPAEhPhS0_+0x7a>
		return status;
	}
	if (*bufferSize != 2 || validBits != 0) {		// ATQA must be exactly 16 bits.
 b24:	f4 01       	movw	r30, r8
 b26:	80 81       	ld	r24, Z
 b28:	82 30       	cpi	r24, 0x02	; 2
 b2a:	41 f4       	brne	.+16     	; 0xb3c <_ZN7MFRC52217PICC_REQA_or_WUPAEhPhS0_+0x78>
 b2c:	81 e0       	ldi	r24, 0x01	; 1
 b2e:	99 81       	ldd	r25, Y+1	; 0x01
 b30:	91 11       	cpse	r25, r1
 b32:	05 c0       	rjmp	.+10     	; 0xb3e <_ZN7MFRC52217PICC_REQA_or_WUPAEhPhS0_+0x7a>
 b34:	80 e0       	ldi	r24, 0x00	; 0
 b36:	03 c0       	rjmp	.+6      	; 0xb3e <_ZN7MFRC52217PICC_REQA_or_WUPAEhPhS0_+0x7a>
											) {
	byte validBits;
	MFRC522::StatusCode status;
	
	if (bufferATQA == nullptr || *bufferSize < 2) {	// The ATQA response is 2 bytes long.
		return STATUS_NO_ROOM;
 b38:	84 e0       	ldi	r24, 0x04	; 4
 b3a:	01 c0       	rjmp	.+2      	; 0xb3e <_ZN7MFRC52217PICC_REQA_or_WUPAEhPhS0_+0x7a>
	status = PCD_TransceiveData(&command, 1, bufferATQA, bufferSize, &validBits);
	if (status != STATUS_OK) {
		return status;
	}
	if (*bufferSize != 2 || validBits != 0) {		// ATQA must be exactly 16 bits.
		return STATUS_ERROR;
 b3c:	81 e0       	ldi	r24, 0x01	; 1
	}
	return STATUS_OK;
} // End PICC_REQA_or_WUPA()
 b3e:	ce 5f       	subi	r28, 0xFE	; 254
 b40:	cd bf       	out	0x3d, r28	; 61
 b42:	df 91       	pop	r29
 b44:	cf 91       	pop	r28
 b46:	1f 91       	pop	r17
 b48:	0f 91       	pop	r16
 b4a:	ff 90       	pop	r15
 b4c:	ef 90       	pop	r14
 b4e:	cf 90       	pop	r12
 b50:	af 90       	pop	r10
 b52:	9f 90       	pop	r9
 b54:	8f 90       	pop	r8
 b56:	7f 90       	pop	r7
 b58:	6f 90       	pop	r6
 b5a:	5f 90       	pop	r5
 b5c:	4f 90       	pop	r4
 b5e:	08 95       	ret

00000b60 <_ZN7MFRC52213PICC_RequestAEPhS0_>:
 * 
 * @return STATUS_OK on success, STATUS_??? otherwise.
 */
MFRC522::StatusCode MFRC522::PICC_RequestA(	byte *bufferATQA,	///< The buffer to store the ATQA (Answer to request) in
											byte *bufferSize	///< Buffer size, at least two bytes. Also number of bytes returned if STATUS_OK.
										) {
 b60:	9a 01       	movw	r18, r20
	return PICC_REQA_or_WUPA(PICC_CMD_REQA, bufferATQA, bufferSize);
 b62:	ab 01       	movw	r20, r22
 b64:	66 e2       	ldi	r22, 0x26	; 38
 b66:	ae cf       	rjmp	.-164    	; 0xac4 <_ZN7MFRC52217PICC_REQA_or_WUPAEhPhS0_>

00000b68 <_ZN7MFRC52221PICC_IsNewCardPresentEv>:
 * Returns true if a PICC responds to PICC_CMD_REQA.
 * Only "new" cards in state IDLE are invited. Sleeping cards in state HALT are ignored.
 * 
 * @return bool
 */
bool MFRC522::PICC_IsNewCardPresent() {
 b68:	0f 93       	push	r16
 b6a:	1f 93       	push	r17
 b6c:	cf 93       	push	r28
 b6e:	df 93       	push	r29
 b70:	cd b7       	in	r28, 0x3d	; 61
 b72:	dd 27       	eor	r29, r29
 b74:	c3 50       	subi	r28, 0x03	; 3
 b76:	cd bf       	out	0x3d, r28	; 61
 b78:	8c 01       	movw	r16, r24
	byte bufferATQA[2];
	byte bufferSize = sizeof(bufferATQA);
 b7a:	82 e0       	ldi	r24, 0x02	; 2
 b7c:	8b 83       	std	Y+3, r24	; 0x03

	// Reset baud rates
	PCD_WriteRegister(TxModeReg, 0x00);
 b7e:	40 e0       	ldi	r20, 0x00	; 0
 b80:	64 e2       	ldi	r22, 0x24	; 36
 b82:	c8 01       	movw	r24, r16
 b84:	5b db       	rcall	.-2378   	; 0x23c <_ZN7MFRC52217PCD_WriteRegisterENS_12PCD_RegisterEh>
	PCD_WriteRegister(RxModeReg, 0x00);
 b86:	40 e0       	ldi	r20, 0x00	; 0
 b88:	66 e2       	ldi	r22, 0x26	; 38
 b8a:	c8 01       	movw	r24, r16
 b8c:	57 db       	rcall	.-2386   	; 0x23c <_ZN7MFRC52217PCD_WriteRegisterENS_12PCD_RegisterEh>
	// Reset ModWidthReg
	PCD_WriteRegister(ModWidthReg, 0x26);
 b8e:	46 e2       	ldi	r20, 0x26	; 38
 b90:	68 e4       	ldi	r22, 0x48	; 72
 b92:	c8 01       	movw	r24, r16
 b94:	53 db       	rcall	.-2394   	; 0x23c <_ZN7MFRC52217PCD_WriteRegisterENS_12PCD_RegisterEh>

	MFRC522::StatusCode result = PICC_RequestA(bufferATQA, &bufferSize);
 b96:	ae 01       	movw	r20, r28
 b98:	4d 5f       	subi	r20, 0xFD	; 253
 b9a:	5f 4f       	sbci	r21, 0xFF	; 255
 b9c:	be 01       	movw	r22, r28
 b9e:	6f 5f       	subi	r22, 0xFF	; 255
 ba0:	7f 4f       	sbci	r23, 0xFF	; 255
 ba2:	c8 01       	movw	r24, r16
 ba4:	dd df       	rcall	.-70     	; 0xb60 <_ZN7MFRC52213PICC_RequestAEPhS0_>
 ba6:	98 2f       	mov	r25, r24
	return (result == STATUS_OK || result == STATUS_COLLISION);
 ba8:	81 e0       	ldi	r24, 0x01	; 1
 baa:	99 23       	and	r25, r25
 bac:	19 f0       	breq	.+6      	; 0xbb4 <_ZN7MFRC52221PICC_IsNewCardPresentEv+0x4c>
 bae:	92 30       	cpi	r25, 0x02	; 2
 bb0:	09 f0       	breq	.+2      	; 0xbb4 <_ZN7MFRC52221PICC_IsNewCardPresentEv+0x4c>
 bb2:	80 e0       	ldi	r24, 0x00	; 0
} // End PICC_IsNewCardPresent()
 bb4:	cd 5f       	subi	r28, 0xFD	; 253
 bb6:	cd bf       	out	0x3d, r28	; 61
 bb8:	df 91       	pop	r29
 bba:	cf 91       	pop	r28
 bbc:	1f 91       	pop	r17
 bbe:	0f 91       	pop	r16
 bc0:	08 95       	ret

00000bc2 <_ZN8SPIClassC1Ev>:
*/


SPIClass::SPIClass() {
	// TODO Auto-generated constructor stub
	clkdiv = 10;
 bc2:	2a e0       	ldi	r18, 0x0A	; 10
 bc4:	fc 01       	movw	r30, r24
 bc6:	21 83       	std	Z+1, r18	; 0x01
 bc8:	08 95       	ret

00000bca <_ZN8SPIClassD1Ev>:
	// TODO Auto-generated constructor stub
	clkdiv = 10;
}


SPIClass::~SPIClass() {
 bca:	08 95       	ret

00000bcc <_ZN8SPIClass9stopTimerEv>:

/**
 * @brief Kept the Counter in Reset State. It ensueres the counter is halted.
 **/
void SPIClass::stopTimer(){
	GTCCR |= _BV(TSM);
 bcc:	8c b5       	in	r24, 0x2c	; 44
 bce:	80 68       	ori	r24, 0x80	; 128
 bd0:	8c bd       	out	0x2c, r24	; 44
	GTCCR |= _BV(PSR0);
 bd2:	8c b5       	in	r24, 0x2c	; 44
 bd4:	81 60       	ori	r24, 0x01	; 1
 bd6:	8c bd       	out	0x2c, r24	; 44
 bd8:	08 95       	ret

00000bda <_ZN8SPIClass10startTimerEv>:

/**
 * @brief PSR0 will be cleared by Hardware and the counter will start counting.
 **/
void SPIClass::startTimer(){
	GTCCR |= _BV(PSR0);
 bda:	8c b5       	in	r24, 0x2c	; 44
 bdc:	81 60       	ori	r24, 0x01	; 1
 bde:	8c bd       	out	0x2c, r24	; 44
	GTCCR &= ~_BV(TSM);
 be0:	8c b5       	in	r24, 0x2c	; 44
 be2:	8f 77       	andi	r24, 0x7F	; 127
 be4:	8c bd       	out	0x2c, r24	; 44
 be6:	08 95       	ret

00000be8 <_ZN8SPIClass14setCounterModeEv>:
/**
 * @brief Set counter mode, with Clear Timer on Compare Match mode.
 **/
void SPIClass::setCounterMode(){
	//Set CTC mode.
	TCCR0A |= _BV(WGM01);
 be8:	8a b5       	in	r24, 0x2a	; 42
 bea:	82 60       	ori	r24, 0x02	; 2
 bec:	8a bd       	out	0x2a, r24	; 42

	//Clear and enable interrupts.
	TIFR |= _BV(OCF0A);              // Clear output compare interrupt flag
 bee:	88 b7       	in	r24, 0x38	; 56
 bf0:	80 61       	ori	r24, 0x10	; 16
 bf2:	88 bf       	out	0x38, r24	; 56
	TIMSK |= _BV(OCIE0A);             // Enable output compare interrupt
 bf4:	89 b7       	in	r24, 0x39	; 57
 bf6:	80 61       	ori	r24, 0x10	; 16
 bf8:	89 bf       	out	0x39, r24	; 57
 bfa:	08 95       	ret

00000bfc <_ZN8SPIClass14setCounterTimeEv>:

/**
 * @brief Set Counter Time.
 **/
void SPIClass::setCounterTime(){
	TCCR0B |= _BV(CS01); //clkIO/8 preescaling.
 bfc:	83 b7       	in	r24, 0x33	; 51
 bfe:	82 60       	ori	r24, 0x02	; 2
 c00:	83 bf       	out	0x33, r24	; 51
	OCR0A = 0x68;//CYCLES_PER_BIT;
 c02:	88 e6       	ldi	r24, 0x68	; 104
 c04:	89 bd       	out	0x29, r24	; 41
	TCNT0 = 0;                      // Count up from 0
 c06:	12 be       	out	0x32, r1	; 50
 c08:	08 95       	ret

00000c0a <_ZN8SPIClass9configSPIE11SPISettings>:
 * @pre The Counter should configured, but stopped PSR0=0.
 */
void SPIClass::configSPI(SPISettings settings){
	//USICR |=  _BV(USIOIE) | _BV(USIWM0) | _BV(USICS0);	// No funciona, Reloj mitad de periodo que la salida.

	USICR |=  _BV(USIOIE) | _BV(USIWM0) | _BV(USICS1) | _BV(USICLK); // Software CLK. Positive Edge.
 c0a:	8d b1       	in	r24, 0x0d	; 13
 c0c:	8a 65       	ori	r24, 0x5A	; 90
 c0e:	8d b9       	out	0x0d, r24	; 13

	if (settings.spiMode == SPISettings::SPI_MODE0){
 c10:	61 11       	cpse	r22, r1
 c12:	03 c0       	rjmp	.+6      	; 0xc1a <_ZN8SPIClass9configSPIE11SPISettings+0x10>
		USICR |=  _BV(USIOIE) | _BV(USIWM0) | _BV(USICS1) | _BV(USICLK); // Software CLK. Positive Edge.
 c14:	8d b1       	in	r24, 0x0d	; 13
 c16:	8a 65       	ori	r24, 0x5A	; 90
 c18:	04 c0       	rjmp	.+8      	; 0xc22 <_ZN8SPIClass9configSPIE11SPISettings+0x18>
	}

	if (settings.spiMode == SPISettings::SPI_MODE3){
 c1a:	63 30       	cpi	r22, 0x03	; 3
 c1c:	19 f4       	brne	.+6      	; 0xc24 <_ZN8SPIClass9configSPIE11SPISettings+0x1a>
		USICR |=  _BV(USIOIE) | _BV(USIWM0) | _BV(USICS1) | _BV(USICS0) | _BV(USICLK); // Software CLK. Negative Edge.
 c1e:	8d b1       	in	r24, 0x0d	; 13
 c20:	8e 65       	ori	r24, 0x5E	; 94
 c22:	8d b9       	out	0x0d, r24	; 13
 c24:	08 95       	ret

00000c26 <_ZN8SPIClass5beginEv>:
void SPIClass::setClockDivider(uint8_t div){clkdiv = div;};
void SPIClass::setBitOrder(uint8_t order){bitorder = order;};
*/

void SPIClass::begin(){
	spi_state = IDLE;
 c26:	fc 01       	movw	r30, r24
 c28:	10 82       	st	Z, r1
 c2a:	08 95       	ret

00000c2c <_ZN8SPIClass16beginTransactionE11SPISettings>:
void SPIClass::stop(){
	spi_state = STOP;

}

void SPIClass::beginTransaction(SPISettings settings){
 c2c:	cf 92       	push	r12
 c2e:	df 92       	push	r13
 c30:	ef 92       	push	r14
 c32:	cf 93       	push	r28
 c34:	df 93       	push	r29
 c36:	ec 01       	movw	r28, r24
 c38:	6a 01       	movw	r12, r20
 c3a:	e6 2e       	mov	r14, r22
//Configure the USI to these settings.

	// Stop and reset Timer.
	stopTimer();
 c3c:	c7 df       	rcall	.-114    	; 0xbcc <_ZN8SPIClass9stopTimerEv>
	// Configure
	setCounterMode();
 c3e:	ce 01       	movw	r24, r28
 c40:	d3 df       	rcall	.-90     	; 0xbe8 <_ZN8SPIClass14setCounterModeEv>
	//Calculate from SPISettings.
	setCounterTime();
 c42:	ce 01       	movw	r24, r28
 c44:	db df       	rcall	.-74     	; 0xbfc <_ZN8SPIClass14setCounterTimeEv>

	//Configure USI module as SPI.
	configSPI(settings);
 c46:	6e 2d       	mov	r22, r14
 c48:	a6 01       	movw	r20, r12
 c4a:	ce 01       	movw	r24, r28
 c4c:	de df       	rcall	.-68     	; 0xc0a <_ZN8SPIClass9configSPIE11SPISettings>

	spi_state = READY;
 c4e:	81 e0       	ldi	r24, 0x01	; 1
 c50:	88 83       	st	Y, r24

};
 c52:	df 91       	pop	r29
 c54:	cf 91       	pop	r28
 c56:	ef 90       	pop	r14
 c58:	df 90       	pop	r13
 c5a:	cf 90       	pop	r12
 c5c:	08 95       	ret

00000c5e <_ZN8SPIClass8transferEh>:

int SPIClass::transfer(uint8_t val){
 c5e:	cf 93       	push	r28
 c60:	df 93       	push	r29
 c62:	ec 01       	movw	r28, r24
	mode = 0;
 c64:	1a 82       	std	Y+2, r1	; 0x02
	spi_state = TRANSMIT;
 c66:	82 e0       	ldi	r24, 0x02	; 2
 c68:	88 83       	st	Y, r24

	//Charges first value

	USIDR = val;
 c6a:	6f b9       	out	0x0f, r22	; 15
	USISR &= ~_BV(0x0F);	//Secounter to 0.
 c6c:	8e b1       	in	r24, 0x0e	; 14
 c6e:	8e b9       	out	0x0e, r24	; 14
	USISR |= _BV(0x07);	//Secounter to 0.
 c70:	77 9a       	sbi	0x0e, 7	; 14
	transmissionSize = 1;
 c72:	81 e0       	ldi	r24, 0x01	; 1
 c74:	80 93 6d 00 	sts	0x006D, r24
	spi_tx_count = 0;
 c78:	10 92 6e 00 	sts	0x006E, r1
	startTimer();
 c7c:	ce 01       	movw	r24, r28
 c7e:	ad df       	rcall	.-166    	; 0xbda <_ZN8SPIClass10startTimerEv>

	while(spi_state == TRANSMIT){
 c80:	88 81       	ld	r24, Y
 c82:	82 30       	cpi	r24, 0x02	; 2
 c84:	29 f4       	brne	.+10     	; 0xc90 <_ZN8SPIClass8transferEh+0x32>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 c86:	82 e0       	ldi	r24, 0x02	; 2
 c88:	8a 95       	dec	r24
 c8a:	f1 f7       	brne	.-4      	; 0xc88 <_ZN8SPIClass8transferEh+0x2a>
 c8c:	00 c0       	rjmp	.+0      	; 0xc8e <_ZN8SPIClass8transferEh+0x30>
 c8e:	f8 cf       	rjmp	.-16     	; 0xc80 <_ZN8SPIClass8transferEh+0x22>
			_delay_us(1);
	};
	return usi_byte_read;
 c90:	80 91 6a 00 	lds	r24, 0x006A
};
 c94:	90 e0       	ldi	r25, 0x00	; 0
 c96:	df 91       	pop	r29
 c98:	cf 91       	pop	r28
 c9a:	08 95       	ret

00000c9c <_ZN8SPIClass14endTransactionEv>:

}


void SPIClass::endTransaction(){
	mode  =0;
 c9c:	fc 01       	movw	r30, r24
 c9e:	12 82       	std	Z+2, r1	; 0x02
	stopTimer();
 ca0:	95 cf       	rjmp	.-214    	; 0xbcc <_ZN8SPIClass9stopTimerEv>

00000ca2 <_ZN8SPIClass18manage_USI_OVF_ISREv>:
};

void SPIClass::manage_USI_OVF_ISR(){
 ca2:	fc 01       	movw	r30, r24
	//void __attribute__((interrupt)) USI_OVF_vect(void){
		spi_tx_count++;
 ca4:	90 91 6e 00 	lds	r25, 0x006E
 ca8:	9f 5f       	subi	r25, 0xFF	; 255
 caa:	90 93 6e 00 	sts	0x006E, r25
		USISR = _BV(USIOIF);
 cae:	80 e4       	ldi	r24, 0x40	; 64
 cb0:	8e b9       	out	0x0e, r24	; 14
		usi_byte_read = USIBR;
 cb2:	80 b3       	in	r24, 0x10	; 16
 cb4:	80 93 6a 00 	sts	0x006A, r24

		if (spi_tx_count < transmissionSize){
 cb8:	90 91 6e 00 	lds	r25, 0x006E
 cbc:	80 91 6d 00 	lds	r24, 0x006D
 cc0:	98 17       	cp	r25, r24
 cc2:	48 f4       	brcc	.+18     	; 0xcd6 <_ZN8SPIClass18manage_USI_OVF_ISREv+0x34>
			//Parece que no es necesario volver a configurar.
			//USICR |=  _BV(USIOIE) | _BV(USIWM0) | _BV(USICS0);
			USIDR = spi_tx_buffer[spi_tx_count];
 cc4:	e0 91 6b 00 	lds	r30, 0x006B
 cc8:	f0 91 6c 00 	lds	r31, 0x006C
 ccc:	e9 0f       	add	r30, r25
 cce:	f1 1d       	adc	r31, r1
 cd0:	80 81       	ld	r24, Z
 cd2:	8f b9       	out	0x0f, r24	; 15
 cd4:	08 95       	ret
		}
		else{
			//GTCCR |= _BV(TSM) | _BV(PSR0);	//Stop clock generation.
			//TIMSK &= ~_BV(OCIE0A);	//Stop Timer Counter ISR. No CLK on USCk
			//USICR = 0;
			transmissionSize = 0;
 cd6:	10 92 6d 00 	sts	0x006D, r1
			spi_state = READY;
 cda:	81 e0       	ldi	r24, 0x01	; 1
 cdc:	80 83       	st	Z, r24
 cde:	08 95       	ret

00000ce0 <_ZN8SPIClass23manage_TIMER0_COMPA_ISREv>:
		}
};

void SPIClass::manage_TIMER0_COMPA_ISR(){
	//ISR(TIMER0_COMPA_vect){
		USICR |= _BV(USITC);
 ce0:	68 9a       	sbi	0x0d, 0	; 13
 ce2:	08 95       	ret

00000ce4 <__vector_2>:


/** @brief Interrupt vector for pin change on PB0
 *	Solo se acepta una pulsacion, despues deshabilitamos.
 */
ISR (PCINT0_vect){
 ce4:	1f 92       	push	r1
 ce6:	0f 92       	push	r0
 ce8:	0f b6       	in	r0, 0x3f	; 63
 cea:	0f 92       	push	r0
 cec:	11 24       	eor	r1, r1
 cee:	8f 93       	push	r24
	uint8_t pinbVal = PINB;
	if (!(pinbVal & 1<<PINB4))   // Trigger if DI is Low
 cf0:	b4 99       	sbic	0x16, 4	; 22
 cf2:	04 c0       	rjmp	.+8      	; 0xcfc <__vector_2+0x18>
	{
		//GIMSK &= ~_BV(PCIE);
		PINB |= _BV(PINB3);
 cf4:	b3 9a       	sbi	0x16, 3	; 22
		spiOn = 1;
 cf6:	81 e0       	ldi	r24, 0x01	; 1
 cf8:	80 93 84 00 	sts	0x0084, r24
	}
}
 cfc:	8f 91       	pop	r24
 cfe:	0f 90       	pop	r0
 d00:	0f be       	out	0x3f, r0	; 63
 d02:	0f 90       	pop	r0
 d04:	1f 90       	pop	r1
 d06:	18 95       	reti

00000d08 <__vector_14>:

extern "C" void USI_OVF_vect (void)  __attribute__ ((signal));
void USI_OVF_vect (void){
 d08:	1f 92       	push	r1
 d0a:	0f 92       	push	r0
 d0c:	0f b6       	in	r0, 0x3f	; 63
 d0e:	0f 92       	push	r0
 d10:	11 24       	eor	r1, r1
 d12:	2f 93       	push	r18
 d14:	3f 93       	push	r19
 d16:	4f 93       	push	r20
 d18:	5f 93       	push	r21
 d1a:	6f 93       	push	r22
 d1c:	7f 93       	push	r23
 d1e:	8f 93       	push	r24
 d20:	9f 93       	push	r25
 d22:	af 93       	push	r26
 d24:	bf 93       	push	r27
 d26:	ef 93       	push	r30
 d28:	ff 93       	push	r31
	SPI.manage_USI_OVF_ISR();
 d2a:	85 e8       	ldi	r24, 0x85	; 133
 d2c:	90 e0       	ldi	r25, 0x00	; 0
 d2e:	b9 df       	rcall	.-142    	; 0xca2 <_ZN8SPIClass18manage_USI_OVF_ISREv>
}
 d30:	ff 91       	pop	r31
 d32:	ef 91       	pop	r30
 d34:	bf 91       	pop	r27
 d36:	af 91       	pop	r26
 d38:	9f 91       	pop	r25
 d3a:	8f 91       	pop	r24
 d3c:	7f 91       	pop	r23
 d3e:	6f 91       	pop	r22
 d40:	5f 91       	pop	r21
 d42:	4f 91       	pop	r20
 d44:	3f 91       	pop	r19
 d46:	2f 91       	pop	r18
 d48:	0f 90       	pop	r0
 d4a:	0f be       	out	0x3f, r0	; 63
 d4c:	0f 90       	pop	r0
 d4e:	1f 90       	pop	r1
 d50:	18 95       	reti

00000d52 <__vector_10>:



extern "C" void TIMER0_COMPA_vect (void)  __attribute__ ((signal));
void TIMER0_COMPA_vect (void){
 d52:	1f 92       	push	r1
 d54:	0f 92       	push	r0
 d56:	0f b6       	in	r0, 0x3f	; 63
 d58:	0f 92       	push	r0
 d5a:	11 24       	eor	r1, r1
 d5c:	2f 93       	push	r18
 d5e:	3f 93       	push	r19
 d60:	4f 93       	push	r20
 d62:	5f 93       	push	r21
 d64:	6f 93       	push	r22
 d66:	7f 93       	push	r23
 d68:	8f 93       	push	r24
 d6a:	9f 93       	push	r25
 d6c:	af 93       	push	r26
 d6e:	bf 93       	push	r27
 d70:	ef 93       	push	r30
 d72:	ff 93       	push	r31
	SPI.manage_TIMER0_COMPA_ISR();
 d74:	85 e8       	ldi	r24, 0x85	; 133
 d76:	90 e0       	ldi	r25, 0x00	; 0
 d78:	b3 df       	rcall	.-154    	; 0xce0 <_ZN8SPIClass23manage_TIMER0_COMPA_ISREv>
};
 d7a:	ff 91       	pop	r31
 d7c:	ef 91       	pop	r30
 d7e:	bf 91       	pop	r27
 d80:	af 91       	pop	r26
 d82:	9f 91       	pop	r25
 d84:	8f 91       	pop	r24
 d86:	7f 91       	pop	r23
 d88:	6f 91       	pop	r22
 d8a:	5f 91       	pop	r21
 d8c:	4f 91       	pop	r20
 d8e:	3f 91       	pop	r19
 d90:	2f 91       	pop	r18
 d92:	0f 90       	pop	r0
 d94:	0f be       	out	0x3f, r0	; 63
 d96:	0f 90       	pop	r0
 d98:	1f 90       	pop	r1
 d9a:	18 95       	reti

00000d9c <main>:
MFRC522 mfrc522(SS_PIN, RST_PIN, &SPI, SPISettings(8, SPISettings::MSBFIRST, SPISettings::SPI_MODE0));

int main(){

	//Prepare and configure interrupts and outputs.
	cli();
 d9c:	f8 94       	cli

	DDRB |= _BV(DDB4) | _BV(DDB3) | _BV(DDB2) | _BV(DDB1);
 d9e:	87 b3       	in	r24, 0x17	; 23
 da0:	8e 61       	ori	r24, 0x1E	; 30
 da2:	87 bb       	out	0x17, r24	; 23
	//DDRB &=  ~_BV(DDB5) & ~_BV(DDB4) & ~_BV(DDB0);	// Default is 0.
	PORTB |= _BV(PORTB0);  //Pull-ups on PB0.
 da4:	c0 9a       	sbi	0x18, 0	; 24

	// Configure Interrupts to detect pin-change on PB0.
	GIMSK |= _BV(PCIE);               // Enable pin change interrupts
 da6:	8b b7       	in	r24, 0x3b	; 59
 da8:	80 62       	ori	r24, 0x20	; 32
 daa:	8b bf       	out	0x3b, r24	; 59
	PCMSK |= _BV(PCINT4);             // Enable pin change on pin PB4
 dac:	ac 9a       	sbi	0x15, 4	; 21


	SPI.begin();
 dae:	85 e8       	ldi	r24, 0x85	; 133
 db0:	90 e0       	ldi	r25, 0x00	; 0
 db2:	39 df       	rcall	.-398    	; 0xc26 <_ZN8SPIClass5beginEv>
	spiOn = 0;
 db4:	10 92 84 00 	sts	0x0084, r1

	sei();
 db8:	78 94       	sei
public:
	enum IF_STATUS {IDLE, READY, TRANSMIT, RECEIVE, STOP};

	SPIClass();
	SPIClass(SPISettings &spiConfig);
	void setDataMode(SPISettings::SPI_MODE spimode){mode = spimode;};
 dba:	10 92 87 00 	sts	0x0087, r1


	//void setSPIConfig();
	SPI.setDataMode(SPISettings::SPI_MODE0);

	mfrc522.PCD_Init();
 dbe:	8f e6       	ldi	r24, 0x6F	; 111
 dc0:	90 e0       	ldi	r25, 0x00	; 0
 dc2:	5e db       	rcall	.-2372   	; 0x480 <_ZN7MFRC5228PCD_InitEv>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 dc4:	2f e7       	ldi	r18, 0x7F	; 127
 dc6:	88 e3       	ldi	r24, 0x38	; 56
 dc8:	91 e0       	ldi	r25, 0x01	; 1
 dca:	21 50       	subi	r18, 0x01	; 1
 dcc:	80 40       	sbci	r24, 0x00	; 0
 dce:	90 40       	sbci	r25, 0x00	; 0
 dd0:	e1 f7       	brne	.-8      	; 0xdca <main+0x2e>
 dd2:	00 c0       	rjmp	.+0      	; 0xdd4 <main+0x38>
 dd4:	00 00       	nop

	//PORTB |= _BV(PINB4);	//Take out from sleep mode.
	_delay_ms(50);

	bool result = mfrc522.PCD_PerformSelfTest();
 dd6:	8f e6       	ldi	r24, 0x6F	; 111
 dd8:	90 e0       	ldi	r25, 0x00	; 0
 dda:	94 db       	rcall	.-2264   	; 0x504 <_ZN7MFRC52219PCD_PerformSelfTestEv>
 ddc:	2f ef       	ldi	r18, 0xFF	; 255
 dde:	80 e7       	ldi	r24, 0x70	; 112
 de0:	92 e0       	ldi	r25, 0x02	; 2
 de2:	21 50       	subi	r18, 0x01	; 1
 de4:	80 40       	sbci	r24, 0x00	; 0
 de6:	90 40       	sbci	r25, 0x00	; 0
 de8:	e1 f7       	brne	.-8      	; 0xde2 <main+0x46>
 dea:	00 c0       	rjmp	.+0      	; 0xdec <main+0x50>
 dec:	00 00       	nop

	while(1){
		//if (spiOn == 1){
		_delay_ms(100);
			SPI.beginTransaction(SPISettings(8, SPISettings::MSBFIRST, SPISettings::SPI_MODE0));
 dee:	48 e0       	ldi	r20, 0x08	; 8
 df0:	51 e0       	ldi	r21, 0x01	; 1
 df2:	60 e0       	ldi	r22, 0x00	; 0
 df4:	85 e8       	ldi	r24, 0x85	; 133
 df6:	90 e0       	ldi	r25, 0x00	; 0
 df8:	19 df       	rcall	.-462    	; 0xc2c <_ZN8SPIClass16beginTransactionE11SPISettings>
			PORTB &= ~_BV(PINB3);	//SS, slave select 0.
 dfa:	c3 98       	cbi	0x18, 3	; 24
			SPI.transfer(0x02);
 dfc:	62 e0       	ldi	r22, 0x02	; 2
 dfe:	85 e8       	ldi	r24, 0x85	; 133
 e00:	90 e0       	ldi	r25, 0x00	; 0
 e02:	2d df       	rcall	.-422    	; 0xc5e <_ZN8SPIClass8transferEh>
			//_delay_ms(2);
			SPI.transfer(0x0F);
 e04:	6f e0       	ldi	r22, 0x0F	; 15
 e06:	85 e8       	ldi	r24, 0x85	; 133
 e08:	90 e0       	ldi	r25, 0x00	; 0
 e0a:	29 df       	rcall	.-430    	; 0xc5e <_ZN8SPIClass8transferEh>
			//_delay_ms(20);
			PORTB |= _BV(PINB3);
 e0c:	c3 9a       	sbi	0x18, 3	; 24
			spiOn = 0;
 e0e:	10 92 84 00 	sts	0x0084, r1
		//}
		//_delay_ms(20);
		SPI.endTransaction();
 e12:	85 e8       	ldi	r24, 0x85	; 133
 e14:	90 e0       	ldi	r25, 0x00	; 0
 e16:	42 df       	rcall	.-380    	; 0xc9c <_ZN8SPIClass14endTransactionEv>
 e18:	2f e7       	ldi	r18, 0x7F	; 127
 e1a:	88 e3       	ldi	r24, 0x38	; 56
 e1c:	91 e0       	ldi	r25, 0x01	; 1
 e1e:	21 50       	subi	r18, 0x01	; 1
 e20:	80 40       	sbci	r24, 0x00	; 0
 e22:	90 40       	sbci	r25, 0x00	; 0
 e24:	e1 f7       	brne	.-8      	; 0xe1e <main+0x82>
 e26:	00 c0       	rjmp	.+0      	; 0xe28 <main+0x8c>
 e28:	00 00       	nop
		_delay_ms(50);

		uint8_t readVal = 0xFF;
		do{
			SPI.beginTransaction(SPISettings(8, SPISettings::MSBFIRST, SPISettings::SPI_MODE0));
 e2a:	48 e0       	ldi	r20, 0x08	; 8
 e2c:	51 e0       	ldi	r21, 0x01	; 1
 e2e:	60 e0       	ldi	r22, 0x00	; 0
 e30:	85 e8       	ldi	r24, 0x85	; 133
 e32:	90 e0       	ldi	r25, 0x00	; 0
 e34:	fb de       	rcall	.-522    	; 0xc2c <_ZN8SPIClass16beginTransactionE11SPISettings>
			PORTB &= ~_BV(PINB3);	//SS, slave select 0.
 e36:	c3 98       	cbi	0x18, 3	; 24
			SPI.transfer(0x82);
 e38:	62 e8       	ldi	r22, 0x82	; 130
 e3a:	85 e8       	ldi	r24, 0x85	; 133
 e3c:	90 e0       	ldi	r25, 0x00	; 0
 e3e:	0f df       	rcall	.-482    	; 0xc5e <_ZN8SPIClass8transferEh>
			readVal = SPI.transfer(0x00);
 e40:	60 e0       	ldi	r22, 0x00	; 0
 e42:	85 e8       	ldi	r24, 0x85	; 133
 e44:	90 e0       	ldi	r25, 0x00	; 0
 e46:	0b df       	rcall	.-490    	; 0xc5e <_ZN8SPIClass8transferEh>
 e48:	c8 2f       	mov	r28, r24
			PORTB |= _BV(PINB3);
 e4a:	c3 9a       	sbi	0x18, 3	; 24
			SPI.endTransaction();
 e4c:	85 e8       	ldi	r24, 0x85	; 133
 e4e:	90 e0       	ldi	r25, 0x00	; 0
 e50:	25 df       	rcall	.-438    	; 0xc9c <_ZN8SPIClass14endTransactionEv>
 e52:	8f e1       	ldi	r24, 0x1F	; 31
 e54:	9e e4       	ldi	r25, 0x4E	; 78
 e56:	01 97       	sbiw	r24, 0x01	; 1
 e58:	f1 f7       	brne	.-4      	; 0xe56 <main+0xba>
 e5a:	00 c0       	rjmp	.+0      	; 0xe5c <main+0xc0>
 e5c:	00 00       	nop
		//_delay_ms(20);
		SPI.endTransaction();
		_delay_ms(50);

		uint8_t readVal = 0xFF;
		do{
 e5e:	c4 fd       	sbrc	r28, 4
 e60:	e4 cf       	rjmp	.-56     	; 0xe2a <main+0x8e>
 e62:	bc cf       	rjmp	.-136    	; 0xddc <main+0x40>

00000e64 <_GLOBAL__sub_I_SPI>:
#include "MFRC522.h"

constexpr uint8_t RST_PIN = 4;     // Configurable, see typical pin layout above
constexpr uint8_t SS_PIN = 3;     // Configurable, see typical pin layout above

SPIClass SPI;
 e64:	85 e8       	ldi	r24, 0x85	; 133
 e66:	90 e0       	ldi	r25, 0x00	; 0
 e68:	ac de       	rcall	.-680    	; 0xbc2 <_ZN8SPIClassC1Ev>
	MFRC522() : MFRC522(UNUSED_PIN, UNUSED_PIN) {};
	*/
	MFRC522(const byte chipSelectPin, const byte resetPowerDownPin,
				SPIClass *spiClass, const SPISettings spiSettings)
				: _chipSelectPin(chipSelectPin), _resetPowerDownPin(resetPowerDownPin),
				  _spiClass(spiClass), _spiSettings(spiSettings) {};
 e6a:	ef e6       	ldi	r30, 0x6F	; 111
 e6c:	f0 e0       	ldi	r31, 0x00	; 0
 e6e:	84 e6       	ldi	r24, 0x64	; 100
 e70:	90 e0       	ldi	r25, 0x00	; 0
 e72:	91 83       	std	Z+1, r25	; 0x01
 e74:	80 83       	st	Z, r24
 e76:	83 e0       	ldi	r24, 0x03	; 3
 e78:	86 87       	std	Z+14, r24	; 0x0e
 e7a:	84 e0       	ldi	r24, 0x04	; 4
 e7c:	87 87       	std	Z+15, r24	; 0x0f
 e7e:	85 e8       	ldi	r24, 0x85	; 133
 e80:	90 e0       	ldi	r25, 0x00	; 0
 e82:	91 8b       	std	Z+17, r25	; 0x11
 e84:	80 8b       	std	Z+16, r24	; 0x10
 e86:	88 e0       	ldi	r24, 0x08	; 8
 e88:	82 8b       	std	Z+18, r24	; 0x12
 e8a:	81 e0       	ldi	r24, 0x01	; 1
 e8c:	83 8b       	std	Z+19, r24	; 0x13
 e8e:	14 8a       	std	Z+20, r1	; 0x14
 e90:	08 95       	ret

00000e92 <_GLOBAL__sub_D_SPI>:
 e92:	85 e8       	ldi	r24, 0x85	; 133
 e94:	90 e0       	ldi	r25, 0x00	; 0
 e96:	99 ce       	rjmp	.-718    	; 0xbca <_ZN8SPIClassD1Ev>

00000e98 <_Z12digitalWritehh>:

#include <avr/io.h>
#include "wrapper_arduino.h"

void digitalWrite(uint8_t pin, uint8_t val){
	if (val == 1)
 e98:	61 30       	cpi	r22, 0x01	; 1
 e9a:	11 f4       	brne	.+4      	; 0xea0 <_Z12digitalWritehh+0x8>
		PORTB |= _BV(val);
 e9c:	c1 9a       	sbi	0x18, 1	; 24
 e9e:	08 95       	ret
	else
		PORTB &= ~_BV(val);
 ea0:	28 b3       	in	r18, 0x18	; 24
 ea2:	81 e0       	ldi	r24, 0x01	; 1
 ea4:	90 e0       	ldi	r25, 0x00	; 0
 ea6:	06 2e       	mov	r0, r22
 ea8:	01 c0       	rjmp	.+2      	; 0xeac <_Z12digitalWritehh+0x14>
 eaa:	88 0f       	add	r24, r24
 eac:	0a 94       	dec	r0
 eae:	ea f7       	brpl	.-6      	; 0xeaa <_Z12digitalWritehh+0x12>
 eb0:	80 95       	com	r24
 eb2:	82 23       	and	r24, r18
 eb4:	88 bb       	out	0x18, r24	; 24
 eb6:	08 95       	ret

00000eb8 <_Z7pinModehh>:
};

void pinMode(uint8_t pin, uint8_t dir){
	if (dir ==1)
		DDRB |= _BV(pin);
 eb8:	47 b3       	in	r20, 0x17	; 23
 eba:	21 e0       	ldi	r18, 0x01	; 1
 ebc:	30 e0       	ldi	r19, 0x00	; 0
	else
		PORTB &= ~_BV(val);
};

void pinMode(uint8_t pin, uint8_t dir){
	if (dir ==1)
 ebe:	61 30       	cpi	r22, 0x01	; 1
 ec0:	49 f4       	brne	.+18     	; 0xed4 <_Z7pinModehh+0x1c>
		DDRB |= _BV(pin);
 ec2:	b9 01       	movw	r22, r18
 ec4:	02 c0       	rjmp	.+4      	; 0xeca <_Z7pinModehh+0x12>
 ec6:	66 0f       	add	r22, r22
 ec8:	77 1f       	adc	r23, r23
 eca:	8a 95       	dec	r24
 ecc:	e2 f7       	brpl	.-8      	; 0xec6 <_Z7pinModehh+0xe>
 ece:	cb 01       	movw	r24, r22
 ed0:	84 2b       	or	r24, r20
 ed2:	09 c0       	rjmp	.+18     	; 0xee6 <_Z7pinModehh+0x2e>
	else
		DDRB &= ~_BV(pin);
 ed4:	b9 01       	movw	r22, r18
 ed6:	02 c0       	rjmp	.+4      	; 0xedc <_Z7pinModehh+0x24>
 ed8:	66 0f       	add	r22, r22
 eda:	77 1f       	adc	r23, r23
 edc:	8a 95       	dec	r24
 ede:	e2 f7       	brpl	.-8      	; 0xed8 <_Z7pinModehh+0x20>
 ee0:	cb 01       	movw	r24, r22
 ee2:	80 95       	com	r24
 ee4:	84 23       	and	r24, r20
 ee6:	87 bb       	out	0x17, r24	; 23
 ee8:	08 95       	ret

00000eea <_Z11digitalReadh>:
}

uint8_t digitalRead(uint8_t pin){

	return PINB;
 eea:	86 b3       	in	r24, 0x16	; 22
}
 eec:	08 95       	ret

00000eee <_Z5delayh>:

void delay(uint8_t ms){
	while(ms > 0){
 eee:	88 23       	and	r24, r24
 ef0:	41 f0       	breq	.+16     	; 0xf02 <_Z5delayh+0x14>
 ef2:	ef ec       	ldi	r30, 0xCF	; 207
 ef4:	f7 e0       	ldi	r31, 0x07	; 7
 ef6:	31 97       	sbiw	r30, 0x01	; 1
 ef8:	f1 f7       	brne	.-4      	; 0xef6 <_Z5delayh+0x8>
 efa:	00 c0       	rjmp	.+0      	; 0xefc <_Z5delayh+0xe>
 efc:	00 00       	nop
		_delay_ms(1);
		ms --;
 efe:	81 50       	subi	r24, 0x01	; 1
 f00:	f6 cf       	rjmp	.-20     	; 0xeee <_Z5delayh>
	}
}
 f02:	08 95       	ret

00000f04 <__mulqi3>:
 f04:	00 24       	eor	r0, r0

00000f06 <__mulqi3_loop>:
 f06:	80 fd       	sbrc	r24, 0
 f08:	06 0e       	add	r0, r22
 f0a:	66 0f       	add	r22, r22
 f0c:	11 f0       	breq	.+4      	; 0xf12 <__mulqi3_exit>
 f0e:	86 95       	lsr	r24
 f10:	d1 f7       	brne	.-12     	; 0xf06 <__mulqi3_loop>

00000f12 <__mulqi3_exit>:
 f12:	80 2d       	mov	r24, r0
 f14:	08 95       	ret

00000f16 <__tablejump2__>:
 f16:	ee 0f       	add	r30, r30
 f18:	ff 1f       	adc	r31, r31
 f1a:	05 90       	lpm	r0, Z+
 f1c:	f4 91       	lpm	r31, Z
 f1e:	e0 2d       	mov	r30, r0
 f20:	09 94       	ijmp

00000f22 <__do_global_dtors>:
 f22:	10 e0       	ldi	r17, 0x00	; 0
 f24:	c0 e9       	ldi	r28, 0x90	; 144
 f26:	d0 e0       	ldi	r29, 0x00	; 0
 f28:	03 c0       	rjmp	.+6      	; 0xf30 <__do_global_dtors+0xe>
 f2a:	fe 01       	movw	r30, r28
 f2c:	f4 df       	rcall	.-24     	; 0xf16 <__tablejump2__>
 f2e:	21 96       	adiw	r28, 0x01	; 1
 f30:	c1 39       	cpi	r28, 0x91	; 145
 f32:	d1 07       	cpc	r29, r17
 f34:	d1 f7       	brne	.-12     	; 0xf2a <__do_global_dtors+0x8>
 f36:	f8 94       	cli

00000f38 <__stop_program>:
 f38:	ff cf       	rjmp	.-2      	; 0xf38 <__stop_program>
